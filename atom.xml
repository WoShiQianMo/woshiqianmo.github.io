<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://qianmo.github.io/atom.xml" rel="self"/>
  
  <link href="https://qianmo.github.io/"/>
  <updated>2021-04-06T14:05:06.141Z</updated>
  <id>https://qianmo.github.io/</id>
  
  <author>
    <name>浅陌</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04.多线程与高并发</title>
    <link href="https://qianmo.github.io/2021/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://qianmo.github.io/2021/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/04-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2021-04-06T14:05:06.000Z</published>
    <updated>2021-04-06T14:05:06.141Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>03.多线程与高并发</title>
    <link href="https://qianmo.github.io/2021/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://qianmo.github.io/2021/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2021-04-04T17:28:27.000Z</published>
    <updated>2021-04-06T14:06:12.628Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-AQS-CLH"><a href="#1-AQS-CLH" class="headerlink" title="1.AQS (CLH)"></a>1.AQS (CLH)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h5 id="2-CAS新类型锁-–-ReentrantLock"><a href="#2-CAS新类型锁-–-ReentrantLock" class="headerlink" title="2. CAS新类型锁 – ReentrantLock"></a>2. CAS新类型锁 – ReentrantLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reentrantlock用于替代synchronized</span><br><span class="hljs-comment"> * 本例中由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span><br><span class="hljs-comment"> * 这里是复习synchronized最原始的语义</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(i);<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>) m2();<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;m2 ...&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock rl = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">new</span> Thread(rl::m1).start();<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//new Thread(rl::m2).start();</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reentrantlock用于替代synchronized</span><br><span class="hljs-comment"> * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span><br><span class="hljs-comment"> * 这里是复习synchronized最原始的语义</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以完成同样的功能</span><br><span class="hljs-comment"> * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span><br><span class="hljs-comment"> * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock(); <span class="hljs-comment">//synchronized(this)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>System.out.println(i);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br>System.out.println(<span class="hljs-string">&quot;m2 ...&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock rl = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">new</span> Thread(rl::m1).start();<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">new</span> Thread(rl::m2).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reentrantlock用于替代synchronized</span><br><span class="hljs-comment"> * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span><br><span class="hljs-comment"> * 这里是复习synchronized最原始的语义</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以完成同样的功能</span><br><span class="hljs-comment"> * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span><br><span class="hljs-comment"> * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>System.out.println(i);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</span><br><span class="hljs-comment"> * 可以根据tryLock的返回值来判定是否锁定</span><br><span class="hljs-comment"> * 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">boolean locked = lock.tryLock();</span><br><span class="hljs-comment">System.out.println(&quot;m2 ...&quot; + locked);</span><br><span class="hljs-comment">if(locked) lock.unlock();</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">boolean</span> locked = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>locked = lock.tryLock(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>System.out.println(<span class="hljs-string">&quot;m2 ...&quot;</span> + locked);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span>(locked) lock.unlock();<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReentrantLock rl = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">new</span> Thread(rl::m1).start();<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">new</span> Thread(rl::m2).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reentrantlock用于替代synchronized</span><br><span class="hljs-comment"> * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span><br><span class="hljs-comment"> * 这里是复习synchronized最原始的语义</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以完成同样的功能</span><br><span class="hljs-comment"> * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span><br><span class="hljs-comment"> * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span><br><span class="hljs-comment"> * 在一个线程等待锁的过程中，可以被打断</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br>System.out.println(<span class="hljs-string">&quot;t1 start&quot;</span>);<br>TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>System.out.println(<span class="hljs-string">&quot;t1 end&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;interrupted!&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;);<br>t1.start();<br><br>Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//lock.lock();</span><br>lock.lockInterruptibly(); <span class="hljs-comment">//可以对interrupt()方法做出响应</span><br>System.out.println(<span class="hljs-string">&quot;t2 start&quot;</span>);<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;t2 end&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;interrupted!&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;);<br>t2.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>t2.interrupt(); <span class="hljs-comment">//打断线程2的等待</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="公平锁：先检查队列是否存在等待，存在就进入队列等待"><a href="#公平锁：先检查队列是否存在等待，存在就进入队列等待" class="headerlink" title="公平锁：先检查队列是否存在等待，存在就进入队列等待"></a>公平锁：先检查队列是否存在等待，存在就进入队列等待</h6><h6 id="非公平锁：不论是否存在等待，直接抢锁"><a href="#非公平锁：不论是否存在等待，直接抢锁" class="headerlink" title="非公平锁：不论是否存在等待，直接抢锁"></a>非公平锁：不论是否存在等待，直接抢锁</h6><ul><li>reentrantlock默认非公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reentrantlock用于替代synchronized</span><br><span class="hljs-comment"> * 由于m1锁定this,只有m1执行完毕的时候,m2才能执行</span><br><span class="hljs-comment"> * 这里是复习synchronized最原始的语义</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以完成同样的功能</span><br><span class="hljs-comment"> * 需要注意的是，必须要必须要必须要手动释放锁（重要的事情说三遍）</span><br><span class="hljs-comment"> * 使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用reentrantlock可以进行“尝试锁定”tryLock，这样无法锁定，或者在指定时间内无法锁定，线程可以决定是否继续等待</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</span><br><span class="hljs-comment"> * 在一个线程等待锁的过程中，可以被打断</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ReentrantLock还可以指定为公平锁</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReentrantLock lock=<span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//参数为true表示为公平锁，请对比输出结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span>&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;获得锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span>&#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ReentrantLock rl=<span class="hljs-keyword">new</span> ReentrantLock();<br>        Thread th1=<span class="hljs-keyword">new</span> Thread(rl);<br>        Thread th2=<span class="hljs-keyword">new</span> Thread(rl);<br>        th1.start();<br>        th2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-ReentrantLock-vs-synchronized"><a href="#3-ReentrantLock-vs-synchronized" class="headerlink" title="3. ReentrantLock vs synchronized"></a>3. ReentrantLock vs synchronized</h5><ul><li>cas vs sync   ReentrantLock 底层cas</li><li>trylock </li><li>lockinterupptibly  ReentrantLock 可以被打断</li><li>公平和非公平切换 ReentrantLock 可以选择公平非公平</li></ul><h5 id="4-CountDownLatch类"><a href="#4-CountDownLatch类" class="headerlink" title="4. CountDownLatch类"></a>4. CountDownLatch类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCountDownLatch</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        usingJoin();<br>        usingCountDownLatch();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usingCountDownLatch</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">100</span>];<br>        CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(threads.length);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10000</span>; j++) result += j;<br>                latch.countDown();<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;end latch&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usingJoin</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">100</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10000</span>; j++) result += j;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                threads[i].join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end join&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-CyclicBarrier-可循环屏障"><a href="#5-CyclicBarrier-可循环屏障" class="headerlink" title="5.CyclicBarrier 可循环屏障"></a>5.CyclicBarrier 可循环屏障</h5><ul><li><p>等待线程数堆够要求，可以继续执行</p></li><li><p>限流（实际使用可能使用Guava RateLimiter）</p></li><li><p>复杂操作(顺序执行)</p><ul><li>数据库</li><li>网络</li><li>文件</li></ul></li><li><p>并发执行</p><ul><li>线程-数据库操作</li><li>线程-网络操作 </li></ul><p>等待所有完成以后继续执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCyclicBarrier</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//CyclicBarrier barrier = new CyclicBarrier(20);</span><br><br>        CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">20</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;满人&quot;</span>));<br><br>        <span class="hljs-comment">/*CyclicBarrier barrier = new CyclicBarrier(20, new Runnable() &#123;</span><br><span class="hljs-comment">            @Override</span><br><span class="hljs-comment">            public void run() &#123;</span><br><span class="hljs-comment">                System.out.println(&quot;满人，发车&quot;);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);*/</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        barrier.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-Phaser同步屏障"><a href="#6-Phaser同步屏障" class="headerlink" title="6. Phaser同步屏障"></a>6. Phaser同步屏障</h5><ul><li>按照不同阶段执行，同时共同几个人一起参与（遗传算法问题可能用到）先异步，后同步</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Phaser;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPhaser</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Random r = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">static</span> MarriagePhaser phaser = <span class="hljs-keyword">new</span> MarriagePhaser();<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">milliSleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> milli)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MILLISECONDS.sleep(milli);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        phaser.bulkRegister(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nameIndex = i;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><br>                Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;person &quot;</span> + nameIndex);<br>                p.arrive();<br>                phaser.arriveAndAwaitAdvance();<br><br>                p.eat();<br>                phaser.arriveAndAwaitAdvance();<br><br>                p.leave();<br>                phaser.arriveAndAwaitAdvance();<br>            &#125;).start();<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarriagePhaser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phaser</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAdvance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> phase, <span class="hljs-keyword">int</span> registeredParties)</span> </span>&#123;<br><br>            <span class="hljs-keyword">switch</span> (phase) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人到齐了！&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人吃完了！&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人离开了！&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;婚礼结束！&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>        String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrive</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 到达现场！\n&quot;</span>, name);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 吃完!\n&quot;</span>, name);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leave</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 离开！\n&quot;</span>, name);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Phaser;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPhaser2</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Random r = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">static</span> MarriagePhaser phaser = <span class="hljs-keyword">new</span> MarriagePhaser();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">milliSleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> milli)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MILLISECONDS.sleep(milli);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        phaser.bulkRegister(<span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;p&quot;</span> + i)).start();<br>        &#125;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;新郎&quot;</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;新娘&quot;</span>)).start();<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MarriagePhaser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phaser</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAdvance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> phase, <span class="hljs-keyword">int</span> registeredParties)</span> </span>&#123;<br><br>            <span class="hljs-keyword">switch</span> (phase) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人到齐了！&quot;</span> + registeredParties);<br>                    System.out.println();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人吃完了！&quot;</span> + registeredParties);<br>                    System.out.println();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    System.out.println(<span class="hljs-string">&quot;所有人离开了！&quot;</span> + registeredParties);<br>                    System.out.println();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    System.out.println(<span class="hljs-string">&quot;婚礼结束！新郎新娘抱抱！&quot;</span> + registeredParties);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arrive</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 到达现场！\n&quot;</span>, name);<br>            phaser.arriveAndAwaitAdvance();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 吃完!\n&quot;</span>, name);<br>            phaser.arriveAndAwaitAdvance();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leave</span><span class="hljs-params">()</span> </span>&#123;<br>            milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>            System.out.printf(<span class="hljs-string">&quot;%s 离开！\n&quot;</span>, name);<br>            phaser.arriveAndAwaitAdvance();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hug</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">&quot;新郎&quot;</span>) || name.equals(<span class="hljs-string">&quot;新娘&quot;</span>)) &#123;<br>                milliSleep(r.nextInt(<span class="hljs-number">1000</span>));<br>                System.out.printf(<span class="hljs-string">&quot;%s 洞房！\n&quot;</span>, name);<br>                phaser.arriveAndAwaitAdvance();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                phaser.arriveAndDeregister();<br>                <span class="hljs-comment">//phaser.register()</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            arrive();<br>            eat();<br>            leave();<br>            hug();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-读写锁-ReadWriteLock"><a href="#7-读写锁-ReadWriteLock" class="headerlink" title="7. 读写锁 ReadWriteLock"></a>7. 读写锁 ReadWriteLock</h5><ul><li>共享锁</li><li>排他锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestReadWriteLock</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-keyword">static</span> ReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">static</span> Lock readLock = readWriteLock.readLock();<br>    <span class="hljs-keyword">static</span> Lock writeLock = readWriteLock.writeLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(Lock lock)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;read over!&quot;</span>);<br>            <span class="hljs-comment">//模拟读取操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Lock lock, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            value = v;<br>            System.out.println(<span class="hljs-string">&quot;write over!&quot;</span>);<br>            <span class="hljs-comment">//模拟写操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//Runnable readR = ()-&gt; read(lock);</span><br>        Runnable readR = ()-&gt; read(readLock);<br><br>        <span class="hljs-comment">//Runnable writeR = ()-&gt;write(lock, new Random().nextInt());</span><br>        Runnable writeR = ()-&gt;write(writeLock, <span class="hljs-keyword">new</span> Random().nextInt());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">18</span>; i++) <span class="hljs-keyword">new</span> Thread(readR).start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) <span class="hljs-keyword">new</span> Thread(writeR).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-Semaphore-信号灯"><a href="#8-Semaphore-信号灯" class="headerlink" title="8. Semaphore 信号灯"></a>8. Semaphore 信号灯</h5><ul><li>限流 最多允许多少个线程运行</li><li>acquire()拿到值减1</li><li>release()放回1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSemaphore</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//Semaphore s = new Semaphore(2);</span><br>        Semaphore s = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//允许一个线程同时执行</span><br>        <span class="hljs-comment">//Semaphore s = new Semaphore(1);</span><br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s.acquire();<br>                System.out.println(<span class="hljs-string">&quot;T1 running...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>                System.out.println(<span class="hljs-string">&quot;T1 running...&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                s.release();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s.acquire(); <span class="hljs-comment">//阻塞方法 得到，取得</span><br>                System.out.println(<span class="hljs-string">&quot;T2 running...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>                System.out.println(<span class="hljs-string">&quot;T2 running...&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                s.release();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-Exchanger"><a href="#9-Exchanger" class="headerlink" title="9. Exchanger"></a>9. Exchanger</h5><p>exchange()方法阻塞 只会两个线程交换数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Exchanger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExchanger</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> Exchanger&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            String s = <span class="hljs-string">&quot;T1&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = exchanger.exchange(s);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + s);<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            String s = <span class="hljs-string">&quot;T2&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = exchanger.exchange(s);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + s);<br><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="10-LockSupport"><a href="#10-LockSupport" class="headerlink" title="10. LockSupport"></a>10. LockSupport</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLockSupport</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                System.out.println(i);<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>) &#123;<br>                    LockSupport.park(); <span class="hljs-comment">//停止线程 阻塞</span><br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t.start();<br><br>        LockSupport.unpark(t); <span class="hljs-comment">//解锁当前线程</span><br><br>        <span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">            TimeUnit.SECONDS.sleep(8);</span><br><span class="hljs-comment">        &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">            e.printStackTrace();</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        System.out.println(&quot;after 8 senconds!&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        LockSupport.unpark(t);*/</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="11-练习"><a href="#11-练习" class="headerlink" title="11.练习"></a>11.练习</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 分析下面这个程序，能完成这个功能吗？</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithoutVolatile</span> </span>&#123;<br><br>List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>WithoutVolatile c = <span class="hljs-keyword">new</span> WithoutVolatile();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(c.size() == <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，</span><br><span class="hljs-comment"> * 而且，如果在if 和 break之间被别的线程打断，得到的结果也不精确，</span><br><span class="hljs-comment"> * 该怎么做呢？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithVolatile</span> </span>&#123;<br><br><span class="hljs-comment">//添加volatile，使t2能够得到通知</span><br><span class="hljs-comment">//volatile List lists = new LinkedList();</span><br><span class="hljs-keyword">volatile</span> List lists = Collections.synchronizedList(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;());<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>WithVolatile c = <span class="hljs-keyword">new</span> WithVolatile();<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">TimeUnit.SECONDS.sleep(1);</span><br><span class="hljs-comment">&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">e.printStackTrace();</span><br><span class="hljs-comment">&#125;*/</span><br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(c.size() == <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span><br><span class="hljs-comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 阅读下面的程序，并分析输出结果</span><br><span class="hljs-comment"> * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出</span><br><span class="hljs-comment"> * 想想这是为什么？</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyHoldingLock</span> </span>&#123; <span class="hljs-comment">//wait notify</span><br><br><span class="hljs-comment">//添加volatile，使t2能够得到通知</span><br><span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>NotifyHoldingLock c = <span class="hljs-keyword">new</span> NotifyHoldingLock();<br><br><span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>System.out.println(<span class="hljs-string">&quot;t2启动&quot;</span>);<br><span class="hljs-keyword">if</span>(c.size() != <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>&#125;<br><br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>e1.printStackTrace();<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t1启动&quot;</span>);<br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">if</span>(c.size() == <span class="hljs-number">5</span>) &#123;<br>lock.notify();<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span><br><span class="hljs-comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 阅读下面的程序，并分析输出结果</span><br><span class="hljs-comment"> * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出</span><br><span class="hljs-comment"> * 想想这是为什么？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</span><br><span class="hljs-comment"> * 整个通信过程比较繁琐</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyFreeLock</span> </span>&#123;<br><br><span class="hljs-comment">//添加volatile，使t2能够得到通知</span><br><span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>NotifyFreeLock c = <span class="hljs-keyword">new</span> NotifyFreeLock();<br><br><span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>System.out.println(<span class="hljs-string">&quot;t2启动&quot;</span>);<br><span class="hljs-keyword">if</span>(c.size() != <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br><span class="hljs-comment">//通知t1继续执行</span><br>lock.notify();<br>&#125;<br><br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>e1.printStackTrace();<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t1启动&quot;</span>);<br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">if</span>(c.size() == <span class="hljs-number">5</span>) &#123;<br>lock.notify();<br><span class="hljs-comment">//释放锁，让t2得以执行</span><br><span class="hljs-keyword">try</span> &#123;<br>lock.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span><br><span class="hljs-comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 阅读下面的程序，并分析输出结果</span><br><span class="hljs-comment"> * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出</span><br><span class="hljs-comment"> * 想想这是为什么？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</span><br><span class="hljs-comment"> * 整个通信过程比较繁琐</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用Latch（门闩）替代wait notify来进行通知</span><br><span class="hljs-comment"> * 好处是通信方式简单，同时也可以指定等待时间</span><br><span class="hljs-comment"> * 使用await和countdown方法替代wait和notify</span><br><span class="hljs-comment"> * CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行</span><br><span class="hljs-comment"> * 当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了</span><br><span class="hljs-comment"> * 这时应该考虑countdownlatch/cyclicbarrier/semaphore</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T05_CountDownLatch</span> </span>&#123;<br><br><span class="hljs-comment">// 添加volatile，使t2能够得到通知</span><br><span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>T05_CountDownLatch c = <span class="hljs-keyword">new</span> T05_CountDownLatch();<br><br>CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t2启动&quot;</span>);<br><span class="hljs-keyword">if</span> (c.size() != <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>latch.await();<br><br><span class="hljs-comment">//也可以指定等待时间</span><br><span class="hljs-comment">//latch.await(5000, TimeUnit.MILLISECONDS);</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br><br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>e1.printStackTrace();<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t1启动&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">if</span> (c.size() == <span class="hljs-number">5</span>) &#123;<br><span class="hljs-comment">// 打开门闩，让t2得以执行</span><br>latch.countDown();<br>&#125;<br><br><span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">TimeUnit.SECONDS.sleep(1);</span><br><span class="hljs-comment">&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">e.printStackTrace();</span><br><span class="hljs-comment">&#125;*/</span><br>&#125;<br><br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span><br><span class="hljs-comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 阅读下面的程序，并分析输出结果</span><br><span class="hljs-comment"> * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出</span><br><span class="hljs-comment"> * 想想这是为什么？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</span><br><span class="hljs-comment"> * 整个通信过程比较繁琐</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用Latch（门闩）替代wait notify来进行通知</span><br><span class="hljs-comment"> * 好处是通信方式简单，同时也可以指定等待时间</span><br><span class="hljs-comment"> * 使用await和countdown方法替代wait和notify</span><br><span class="hljs-comment"> * CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行</span><br><span class="hljs-comment"> * 当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了</span><br><span class="hljs-comment"> * 这时应该考虑countdownlatch/cyclicbarrier/semaphore</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">//TODO park unpark</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockSupport</span> </span>&#123;<br><br><span class="hljs-comment">// 添加volatile，使t2能够得到通知</span><br><span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>LockSupport c = <span class="hljs-keyword">new</span> LockSupport();<br><br>CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><br>Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t2启动&quot;</span>);<br><span class="hljs-keyword">if</span> (c.size() != <span class="hljs-number">5</span>) &#123;<br><br>LockSupport.park();<br><br>&#125;<br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br><br><br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>t2.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>e1.printStackTrace();<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t1启动&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">if</span> (c.size() == <span class="hljs-number">5</span>) &#123;<br>LockSupport.unpark(t2);<br>&#125;<br><br><span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">TimeUnit.SECONDS.sleep(1);</span><br><span class="hljs-comment">&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">e.printStackTrace();</span><br><span class="hljs-comment">&#125;*/</span><br>&#125;<br><br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 曾经的面试题：（淘宝？）</span><br><span class="hljs-comment"> * 实现一个容器，提供两个方法，add，size</span><br><span class="hljs-comment"> * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 给lists添加volatile之后，t2能够接到通知，但是，t2线程的死循环很浪费cpu，如果不用死循环，该怎么做呢？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这里使用wait和notify做到，wait会释放锁，而notify不会释放锁</span><br><span class="hljs-comment"> * 需要注意的是，运用这种方法，必须要保证t2先执行，也就是首先让t2监听才可以</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 阅读下面的程序，并分析输出结果</span><br><span class="hljs-comment"> * 可以读到输出结果并不是size=5时t2退出，而是t1结束时t2才接收到通知而退出</span><br><span class="hljs-comment"> * 想想这是为什么？</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * notify之后，t1必须释放锁，t2退出后，也必须notify，通知t1继续执行</span><br><span class="hljs-comment"> * 整个通信过程比较繁琐</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用Latch（门闩）替代wait notify来进行通知</span><br><span class="hljs-comment"> * 好处是通信方式简单，同时也可以指定等待时间</span><br><span class="hljs-comment"> * 使用await和countdown方法替代wait和notify</span><br><span class="hljs-comment"> * CountDownLatch不涉及锁定，当count的值为零时当前线程继续运行</span><br><span class="hljs-comment"> * 当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了</span><br><span class="hljs-comment"> * 这时应该考虑countdownlatch/cyclicbarrier/semaphore</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mashibing</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">//TODO park unpark</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockSupport_WithoutSleep</span> </span>&#123;<br><br><span class="hljs-comment">// 添加volatile，使t2能够得到通知</span><br><span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>lists.add(o);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lists.size();<br>&#125;<br><br><span class="hljs-keyword">static</span> Thread t1 = <span class="hljs-keyword">null</span>, t2 = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>LockSupport_WithoutSleep c = <span class="hljs-keyword">new</span> LockSupport_WithoutSleep();<br><br>t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;t1启动&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>c.add(<span class="hljs-keyword">new</span> Object());<br>System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><span class="hljs-keyword">if</span> (c.size() == <span class="hljs-number">5</span>) &#123;<br>LockSupport.unpark(t2);<br>LockSupport.park();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">//System.out.println(&quot;t2启动&quot;);</span><br><span class="hljs-comment">//if (c.size() != 5) &#123;</span><br><br>LockSupport.park();<br><br><span class="hljs-comment">//&#125;</span><br>System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>LockSupport.unpark(t1);<br><br><br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>t2.start();<br>t1.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span> </span>&#123;<br>    <span class="hljs-comment">// 添加volatile，使t2能够得到通知</span><br>    <span class="hljs-keyword">volatile</span> List lists = <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        lists.add(o);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lists.size();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Thread t1 = <span class="hljs-keyword">null</span>, t2 = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Semaphore c = <span class="hljs-keyword">new</span> Semaphore();<br>        Semaphore s = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">1</span>);<br><br>        t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s.acquire();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    c.add(<span class="hljs-keyword">new</span> Object());<br>                    System.out.println(<span class="hljs-string">&quot;add &quot;</span> + i);<br><br><br>                &#125;<br>                s.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                t2.start();<br>                t2.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                s.acquire();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    System.out.println(i);<br>                &#125;<br>                s.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s.acquire();<br>                System.out.println(<span class="hljs-string">&quot;t2 结束&quot;</span>);<br>                s.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        <span class="hljs-comment">//t2.start();</span><br>        t1.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，</span><br><span class="hljs-comment"> * 能够支持2个生产者线程以及10个消费者线程的阻塞调用</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用wait和notify/notifyAll来实现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContainer1</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; lists = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10</span>; <span class="hljs-comment">//最多10个元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T t)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(lists.size() == MAX) &#123; <span class="hljs-comment">//想想为什么用while而不是用if？</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">//effective java</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>lists.add(t);<br>++count;<br><span class="hljs-keyword">this</span>.notifyAll(); <span class="hljs-comment">//通知消费者线程进行消费</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>T t = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">while</span>(lists.size() == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.wait();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>t = lists.removeFirst();<br>count --;<br><span class="hljs-keyword">this</span>.notifyAll(); <span class="hljs-comment">//通知生产者进行生产</span><br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MyContainer1&lt;String&gt; c = <span class="hljs-keyword">new</span> MyContainer1&lt;&gt;();<br><span class="hljs-comment">//启动消费者线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">5</span>; j++) System.out.println(c.get());<br>&#125;, <span class="hljs-string">&quot;c&quot;</span> + i).start();<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br><span class="hljs-comment">//启动生产者线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + j);<br>&#125;, <span class="hljs-string">&quot;p&quot;</span> + i).start();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，</span><br><span class="hljs-comment"> * 能够支持2个生产者线程以及10个消费者线程的阻塞调用</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用wait和notify/notifyAll来实现</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用Lock和Condition来实现</span><br><span class="hljs-comment"> * 对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContainer2</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; lists = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10</span>; <span class="hljs-comment">//最多10个元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">private</span> Condition producer = lock.newCondition();<br><span class="hljs-keyword">private</span> Condition consumer = lock.newCondition();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T t)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span>(lists.size() == MAX) &#123; <span class="hljs-comment">//想想为什么用while而不是用if？</span><br>producer.await();<br>&#125;<br><br>lists.add(t);<br>++count;<br>consumer.signalAll(); <span class="hljs-comment">//通知消费者线程进行消费</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>T t = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>lock.lock();<br><span class="hljs-keyword">while</span>(lists.size() == <span class="hljs-number">0</span>) &#123;<br>consumer.await();<br>&#125;<br>t = lists.removeFirst();<br>count --;<br>producer.signalAll(); <span class="hljs-comment">//通知生产者进行生产</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>MyContainer2&lt;String&gt; c = <span class="hljs-keyword">new</span> MyContainer2&lt;&gt;();<br><span class="hljs-comment">//启动消费者线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">5</span>; j++) System.out.println(c.get());<br>&#125;, <span class="hljs-string">&quot;c&quot;</span> + i).start();<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br><span class="hljs-comment">//启动生产者线程</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">25</span>; j++) c.put(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + j);<br>&#125;, <span class="hljs-string">&quot;p&quot;</span> + i).start();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-AQS-CLH&quot;&gt;&lt;a href=&quot;#1-AQS-CLH&quot; class=&quot;headerlink&quot; title=&quot;1.AQS (CLH)&quot;&gt;&lt;/a&gt;1.AQS (CLH)&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="复习" scheme="https://qianmo.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>02.多线程与高并发</title>
    <link href="https://qianmo.github.io/2021/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://qianmo.github.io/2021/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/02-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2021-04-03T08:30:23.000Z</published>
    <updated>2021-04-06T14:05:58.862Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1. volatile"></a>1. volatile</h5><p>volatile的可见性和禁止指令重排序怎么实现的？</p><ul><li>保证线程可见性<ul><li>MESI </li><li> CPU的缓存一致性协议</li></ul></li><li>禁止指令重排序 <ul><li>JMM模型中有8个指令完成数据的读写，通过其中load和store指令相互组合成的4个内存屏障实现指令重排序</li><li>DCL单例</li><li>Double Check Lock</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * volatile 关键字，使一个变量在多个线程间可见</span><br><span class="hljs-comment"> * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</span><br><span class="hljs-comment"> * 使用volatile关键字，会让所有线程都会读到变量的修改值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 在下面的代码中，running是存在于堆内存的t对象中</span><br><span class="hljs-comment"> * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去</span><br><span class="hljs-comment"> * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用volatile，将会强制所有线程都去堆内存中读取running的值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 可以阅读这篇文章进行更深入的理解</span><br><span class="hljs-comment"> * http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T01_HelloVolatile</span> </span>&#123;<br><span class="hljs-comment">/*volatile*/</span> <span class="hljs-keyword">boolean</span> running = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;m start&quot;</span>);<br><span class="hljs-keyword">while</span>(running) &#123;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;m end!&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Volatile t = <span class="hljs-keyword">new</span> Volatile();<br><span class="hljs-keyword">new</span> Thread(t::m, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-comment">//lambda 表达式 new Thread(new Runnable( run()&#123;m()&#125;))</span><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>t.running = <span class="hljs-keyword">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mgr</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Mgr INSTANCE = <span class="hljs-keyword">new</span> Mgr();<br>    <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h5 id="3-指令重排序"><a href="#3-指令重排序" class="headerlink" title="3.指令重排序"></a>3.指令重排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mgr</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Mgr INSTANCE;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-synchronized优化"><a href="#4-synchronized优化" class="headerlink" title="4. synchronized优化"></a>4. synchronized优化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 锁粒度细化</span><br><span class="hljs-comment"> *  如果争抢频繁，优化需要锁粒度粗化</span><br><span class="hljs-comment"> * synchronized优化</span><br><span class="hljs-comment"> * 同步代码块中的语句越少越好</span><br><span class="hljs-comment"> * 比较m1和m2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FineCoarseLock</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//do sth need not sync</span><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span><br>count ++;<br><br><span class="hljs-comment">//do sth need not sync</span><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//do sth need not sync</span><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span><br><span class="hljs-comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span><br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>count ++;<br>&#125;<br><span class="hljs-comment">//do sth need not sync</span><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 锁定某对象o，如果o的属性发生改变，不影响锁的使用</span><br><span class="hljs-comment"> * 但是如果o变成另外一个对象，则锁定的对象发生改变</span><br><span class="hljs-comment"> * 应该避免将锁定对象的引用变成另外的对象</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncSameObject</span> </span>&#123;<br><span class="hljs-comment">/*final*/</span> Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(o) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(Thread.currentThread().getName());<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SyncSameObject t = <span class="hljs-keyword">new</span> SyncSameObject();<br><span class="hljs-comment">//启动第一个线程</span><br><span class="hljs-keyword">new</span> Thread(t::m, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//创建第二个线程</span><br>Thread t2 = <span class="hljs-keyword">new</span> Thread(t::m, <span class="hljs-string">&quot;t2&quot;</span>);<br>t.o = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">//锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span><br>t2.start();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不要以字符串常量作为锁定对象</span><br><span class="hljs-comment"> * 在下面的例子中，m1和m2其实锁定的是同一个对象</span><br><span class="hljs-comment"> * 这种情况还会发生比较诡异的现象，比如你用到了一个类库，在该类库中代码锁定了字符串“Hello”，</span><br><span class="hljs-comment"> * 但是你读不到源码，所以你在自己的代码中也锁定了&quot;Hello&quot;,这时候就有可能发生非常诡异的死锁阻塞，</span><br><span class="hljs-comment"> * 因为你的程序和你用到的类库不经意间使用了同一把锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.mashibing.juc.c_017_MoreAboutSync;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoNotLockString</span> </span>&#123;<br><br>String s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(s1) &#123;<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(s2) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="5-CAS-无锁优化-自旋-乐观锁"><a href="#5-CAS-无锁优化-自旋-乐观锁" class="headerlink" title="5. CAS (无锁优化 自旋) 乐观锁"></a>5. CAS (无锁优化 自旋) 乐观锁</h5><ul><li><p>Compare And Set</p><ul><li><p>cas(V,Expected,NewValue)</p><ul><li><p>if V == E</p><p>V = New</p><p>otherwise try again or fail</p></li><li><p>CPU原语支持</p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解决同样的问题的更高效的方法，使用AtomXXX类</span><br><span class="hljs-comment"> * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> </span>&#123;<br><span class="hljs-comment">/*volatile*/</span> <span class="hljs-comment">//int count1 = 0;</span><br><br>AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>); <br><br><span class="hljs-comment">/*synchronized*/</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br><span class="hljs-comment">//if count1.get() &lt; 1000</span><br>count.incrementAndGet(); <span class="hljs-comment">//count1++</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>AtomicInteger t = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>threads.add(<span class="hljs-keyword">new</span> Thread(t::m, <span class="hljs-string">&quot;thread-&quot;</span> + i));<br>&#125;<br><br>threads.forEach((o) -&gt; o.start());<br><br>threads.forEach((o) -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br>o.join();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br>System.out.println(t.count);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617555785597.png" alt="1617555785597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicVsSyncVsLongAdder</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> count2 = <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">static</span> AtomicLong count1 = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0L</span>);<br>    <span class="hljs-keyword">static</span> LongAdder count3 = <span class="hljs-keyword">new</span> LongAdder();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">1000</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;threads.length; i++) &#123;<br>            threads[i] =<br>                    <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">100000</span>; k++) count1.incrementAndGet();<br>                    &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">for</span>(Thread t : threads ) t.start();<br><br>        <span class="hljs-keyword">for</span> (Thread t : threads) t.join();<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br><br>        <span class="hljs-comment">//TimeUnit.SECONDS.sleep(10);</span><br><br>        System.out.println(<span class="hljs-string">&quot;Atomic: &quot;</span> + count1.get() + <span class="hljs-string">&quot; time &quot;</span> + (end-start));<br>        <span class="hljs-comment">//-----------------------------------------------------------</span><br>        Object lock = <span class="hljs-keyword">new</span> Object();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;threads.length; i++) &#123;<br>            threads[i] =<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100000</span>; k++)<br>                            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                                count2++;<br>                            &#125;<br>                    &#125;<br>                &#125;);<br>        &#125;<br><br>        start = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">for</span>(Thread t : threads ) t.start();<br><br>        <span class="hljs-keyword">for</span> (Thread t : threads) t.join();<br><br>        end = System.currentTimeMillis();<br><br><br>        System.out.println(<span class="hljs-string">&quot;Sync: &quot;</span> + count2 + <span class="hljs-string">&quot; time &quot;</span> + (end-start));<br><br><br>        <span class="hljs-comment">//----------------------------------</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;threads.length; i++) &#123;<br>            threads[i] =<br>                    <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;<span class="hljs-number">100000</span>; k++) count3.increment();<br>                    &#125;);<br>        &#125;<br><br>        start = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">for</span>(Thread t : threads ) t.start();<br><br>        <span class="hljs-keyword">for</span> (Thread t : threads) t.join();<br><br>        end = System.currentTimeMillis();<br><br>        <span class="hljs-comment">//TimeUnit.SECONDS.sleep(10);</span><br><br>        System.out.println(<span class="hljs-string">&quot;LongAdder: &quot;</span> + count1.longValue() + <span class="hljs-string">&quot; time &quot;</span> + (end-start));<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">microSleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MICROSECONDS.sleep(m);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617558032869.png" alt="1617558032869"></p><p>LongAdder速度最快  采用分段锁，最后合并结果，求出sum，同样是CAS操作</p><h5 id="6-CAS中ABA问题"><a href="#6-CAS中ABA问题" class="headerlink" title="6.  CAS中ABA问题"></a>6.  CAS中ABA问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">如果 多线程 期望值为<span class="hljs-number">1</span> 其中一个线程由<span class="hljs-number">1</span> 变成<span class="hljs-number">2</span> 然后又变回<span class="hljs-number">1</span> 另一个线程使用<br>    解决ABA问题 加version<br>    AtomicStampedReference解决ABA问题<br>    基础数据类型没有问题<br>    如果是对象会有问题<br></code></pre></td></tr></table></figure><h5 id="7-Unsafe类"><a href="#7-Unsafe类" class="headerlink" title="7. Unsafe类"></a>7. Unsafe类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">所有Atomic方法，底层都是CompareAndSet，都是在Unsafe类中<br> JDK11 weakCompareAndSet可能使用弱指针（软弱虚 弱指针垃圾回收效率高）<br> Unsafe类使用了单例模式<br> JDK8 不允许使用Unsafe<br> JDK11 允许使用Unsfae Unsafe可以直接操作虚拟机内存<br>    allocateMemory 方法实现C (malloc free)，C++(<span class="hljs-keyword">new</span> delete)相当于指针分配内存能力<br>    freeMemory方法<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-volatile&quot;&gt;&lt;a href=&quot;#1-volatile&quot; class=&quot;headerlink&quot; title=&quot;1. volatile&quot;&gt;&lt;/a&gt;1. volatile&lt;/h5&gt;&lt;p&gt;volatile的可见性和禁止指令重排序怎么实现的？&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="复习" scheme="https://qianmo.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>01.多线程与高并发</title>
    <link href="https://qianmo.github.io/2021/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://qianmo.github.io/2021/04/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2021-04-03T06:47:03.000Z</published>
    <updated>2021-04-11T03:24:10.395Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-线程：程序内不同的执行路径"><a href="#1-线程：程序内不同的执行路径" class="headerlink" title="1.线程：程序内不同的执行路径"></a>1.线程：程序内不同的执行路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">import java.util.concurrent.TimeUnit;<br><br>public class WhatIsThread &#123;<br>    private static class T1 extends Thread &#123;<br>        @Override<br>        public void run() &#123;<br>           for(int i&#x3D;0; i&lt;10; i++) &#123;<br>               try &#123;<br>                   TimeUnit.MICROSECONDS.sleep(1);<br>               &#125; catch (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               System.out.println(&quot;T1&quot;);<br>           &#125;<br>        &#125;<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>        &#x2F;&#x2F;new T1().run();<br>        new T1().start();<br>        for(int i&#x3D;0; i&lt;10; i++) &#123;<br>            try &#123;<br>                TimeUnit.MICROSECONDS.sleep(1);<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(&quot;main&quot;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>new T1().start();</p><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617434061438.png" alt="new T1().start()结果"></p><p>new T1().run();</p><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617434154485.png" alt="new T1().run()结果"></p><h5 id="2-线程的创建方式-继承Thread类，实现Runnable，lambda表达式new-Thread-gt"><a href="#2-线程的创建方式-继承Thread类，实现Runnable，lambda表达式new-Thread-gt" class="headerlink" title="2.线程的创建方式    (继承Thread类，实现Runnable，lambda表达式new Thread()-&gt;{})"></a>2.线程的创建方式    (继承Thread类，实现Runnable，lambda表达式new Thread()-&gt;{})</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HowToCreateThread</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello MyThread!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello MyRun!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> MyThread().start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRun()).start();<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello Lambda!&quot;</span>);<br>        &#125;).start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-启动线程的三种方式"><a href="#3-启动线程的三种方式" class="headerlink" title="3.启动线程的三种方式"></a>3.启动线程的三种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1：Thread 2: Runnable 3:Executors.newCachedThrad<br></code></pre></td></tr></table></figure><h5 id="4-线程的基本方法"><a href="#4-线程的基本方法" class="headerlink" title="4.线程的基本方法"></a>4.线程的基本方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">ublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep_Yield_Join</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        testSleep();    //线程睡眠，返回就绪状态</span><br><span class="hljs-comment">//        testYield();  //线程退出，让出CPU，进入等待队列，返回就绪状态</span><br>        testJoin();  <span class="hljs-comment">//2个线程，线程1执行到某点，加入线程2执行，线程1等待线程2执行完毕后继续执行t1</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSleep</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-comment">//TimeUnit.Milliseconds.sleep(500)</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testYield</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span> + i);<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>) Thread.yield();<br><br><br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;------------B&quot;</span> + i);<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>) Thread.yield();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJoin</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-comment">//TimeUnit.Milliseconds.sleep(500)</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                t1.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                    <span class="hljs-comment">//TimeUnit.Milliseconds.sleep(500)</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-线程的状态"><a href="#5-线程的状态" class="headerlink" title="5.线程的状态"></a>5.线程的状态</h5><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617436538930.png" alt="线程的状态"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-keyword">this</span>.getState());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> MyThread();<br>        System.out.println(t.getState());<br>        t.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(t.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617435281972.png" alt="ThreadState结果"></p><h5 id="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"><a href="#Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解" class="headerlink" title="Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解"></a>Thread类中interrupt（）、interrupted（）和isInterrupted（）方法详解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">待完善<br></code></pre></td></tr></table></figure><h5 id="6-synchronized-关键字的基本概念-多个线程访问临界资源"><a href="#6-synchronized-关键字的基本概念-多个线程访问临界资源" class="headerlink" title="6. synchronized 关键字的基本概念  多个线程访问临界资源"></a>6. synchronized 关键字的基本概念  多个线程访问临界资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">private</span> Object o = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(o) &#123; <span class="hljs-comment">//任何线程要执行下面的代码，必须先拿到o的锁</span><br>count--;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count = &quot;</span> + count);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-synchronized-特性"><a href="#7-synchronized-特性" class="headerlink" title="7. synchronized 特性"></a>7. synchronized 特性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">//任何线程要执行下面的代码，必须先拿到this的锁</span><br>count--;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count = &quot;</span> + count);<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//等同于在方法的代码执行时要synchronized(this)</span><br>count--;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count = &quot;</span> + count);<br>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mm</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(T.class) &#123; <span class="hljs-comment">//考虑一下这里写synchronized(this)是否可以？</span><br>count --;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>锁对象前两位，01、00、10、11</p><h5 id="8-分析程序输出"><a href="#8-分析程序输出" class="headerlink" title="8.分析程序输出"></a>8.分析程序输出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-comment">/*volatile*/</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">100</span>;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-comment">/*synchronized*/</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>count--;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count = &quot;</span> + count);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>T t = <span class="hljs-keyword">new</span> T();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-keyword">new</span> Thread(t, <span class="hljs-string">&quot;THREAD&quot;</span> + i).start();<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>synchronized保证了原子性，同时保证了可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 同步和非同步方法是否可以同时调用？可以同时调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123; <br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; m1 start...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">10000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; m1 end&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; m2 &quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>T t = <span class="hljs-keyword">new</span> T();<br><br><span class="hljs-comment">/*new Thread(()-&gt;t.m1(), &quot;t1&quot;).start();</span><br><span class="hljs-comment">new Thread(()-&gt;t.m2(), &quot;t2&quot;).start();*/</span><br><br><span class="hljs-keyword">new</span> Thread(t::m1, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> Thread(t::m2, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//1.8之前的写法</span><br><span class="hljs-comment">new Thread(new Runnable() &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@Override</span><br><span class="hljs-comment">public void run() &#123;</span><br><span class="hljs-comment">t.m1();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;);</span><br><span class="hljs-comment">*/</span><br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题：模拟银行账户</span><br><span class="hljs-comment"> * 对业务写方法加锁</span><br><span class="hljs-comment"> * 对业务读方法不加锁</span><br><span class="hljs-comment"> * 这样行不行？</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 容易产生脏读问题（dirtyRead）</span><br><span class="hljs-comment"> *加锁效率低，能不加锁就不加锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>String name;<br><span class="hljs-keyword">double</span> balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br><br><span class="hljs-keyword">this</span>.balance = balance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-comment">/*synchronized*/</span> <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Account a = <span class="hljs-keyword">new</span> Account();<br><span class="hljs-keyword">new</span> Thread(()-&gt;a.set(<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">100.0</span>)).start();<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>System.out.println(a.getBalance(<span class="hljs-string">&quot;zhangsan&quot;</span>));<br><br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br>System.out.println(a.getBalance(<span class="hljs-string">&quot;zhangsan&quot;</span>));<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="9-synchronized-可重入锁"><a href="#9-synchronized-可重入锁" class="headerlink" title="9. synchronized 可重入锁"></a>9. synchronized 可重入锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span><br><span class="hljs-comment"> * 也就是说synchronized获得的锁是可重入的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;m1 start&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>m2();<br>System.out.println(<span class="hljs-string">&quot;m1 end&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;m2&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> T().m1();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>锁 m类<br>锁 n类<br>如果不能可重入锁 n类 super.m 子类调用父类，就造成死锁</p><p>注：synchronized(Object)</p><ul><li>不能用String常量 Integer Long</li><li>“Object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span><br><span class="hljs-comment"> * 也就是说synchronized获得的锁是可重入的</span><br><span class="hljs-comment"> * 这里是继承中有可能发生的情形，子类调用父类的同步方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;m start&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;m end&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">new</span> TT().m();<br>&#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TT</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;child m start&quot;</span>);<br><span class="hljs-keyword">super</span>.m();<br>System.out.println(<span class="hljs-string">&quot;child m end&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="10-synchronized-异常锁-异常，自动释放锁"><a href="#10-synchronized-异常锁-异常，自动释放锁" class="headerlink" title="10. synchronized 异常锁 (异常，自动释放锁)"></a>10. synchronized 异常锁 (异常，自动释放锁)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 程序在执行过程中，如果出现异常，默认情况锁会被释放</span><br><span class="hljs-comment"> * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span><br><span class="hljs-comment"> * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span><br><span class="hljs-comment"> * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span><br><span class="hljs-comment"> * 因此要非常小心的处理同步业务逻辑中的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start&quot;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>count ++;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; count = &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><br><span class="hljs-keyword">if</span>(count == <span class="hljs-number">5</span>) &#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>; <span class="hljs-comment">//此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span><br>System.out.println(i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>T t = <span class="hljs-keyword">new</span> T();<br>Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>t.m();<br>&#125;<br><br>&#125;;<br><span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">try</span> &#123;<br>TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\QianMo\AppData\Roaming\Typora\typora-user-images\1617501712488.png" alt="1617501712488"></p><h5 id="11-synchronized-底层实现"><a href="#11-synchronized-底层实现" class="headerlink" title="11. synchronized 底层实现"></a>11. synchronized 底层实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">JDK早期 重量级 - 向操作系统OS申请锁<br>后来的改造<br>锁升级的概念<br>sync (Object)<br>markword 记录这个线程ID （偏向锁）<br>如果有线程争用：升级为 自旋锁 （占用CPU，不占用OS，执行时间短（加锁代码），线程数少，用自旋锁）<br>10次以后，还得不到锁， 升级为重量级锁 - 向操作系统OS申请，执行时间长，线程数多，用系统锁<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-线程：程序内不同的执行路径&quot;&gt;&lt;a href=&quot;#1-线程：程序内不同的执行路径&quot; class=&quot;headerlink&quot; title=&quot;1.线程：程序内不同的执行路径&quot;&gt;&lt;/a&gt;1.线程：程序内不同的执行路径&lt;/h5&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="复习" scheme="https://qianmo.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2.Go内存机制</title>
    <link href="https://qianmo.github.io/2021/04/03/go/02-Go%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://qianmo.github.io/2021/04/03/go/02-Go%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-03T06:10:44.000Z</published>
    <updated>2021-04-03T06:29:35.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go内存管理机制"><a href="#Go内存管理机制" class="headerlink" title="Go内存管理机制"></a>Go内存管理机制</h2><h3 id="一-关于Go语言内存机制相关的概念"><a href="#一-关于Go语言内存机制相关的概念" class="headerlink" title="一.关于Go语言内存机制相关的概念"></a>一.关于Go语言内存机制相关的概念</h3><h4 id="1-Go语言的内存划分是什么意思？"><a href="#1-Go语言的内存划分是什么意思？" class="headerlink" title="1.Go语言的内存划分是什么意思？"></a>1.Go语言的内存划分是什么意思？</h4><p>​        Go的内存划分这个概念，强调的是Go的内存管理机制中按照存储的数据的功能类型不同，来划分成不同的数据功能模块。</p><p>​        比如按照功能模块(存放对象的堆区功能模块，辅助进行GC垃圾回收的bitmap区(位图)功能模块)，具体存储对象的mheap区</p><p>mentral,mcache区等。</p><h4 id="2-Go语言的内存空间分配机制概念"><a href="#2-Go语言的内存空间分配机制概念" class="headerlink" title="2.Go语言的内存空间分配机制概念"></a>2.Go语言的内存空间分配机制概念</h4><p>​        Go的内存空间分配机制这个概念强调的是当我在Go程序中创建一个对象，声明一个变量的时候，我用什么样的规则和判断逻辑来确定这些变量存储在哪块内存空间中，或者说把哪块内存空间给到这个变量或者对象进行存储使用，而这些内存空间    (mheap,mcentral,mcache三个空间模块)又如何协调和管理Go的这些对象和变量的。</p><h4 id="3-Go语言的内存模型"><a href="#3-Go语言的内存模型" class="headerlink" title="3.Go语言的内存模型"></a>3.Go语言的内存模型</h4><p>​        Go的内存模型和Java的内存模型要解决的问题类似。</p><p>​        我们回忆下Java的内存模型其中有一个问题就是如何让一个共享变量在多线程间具有可见性，具体是一个线程修改了这个共享变量，另外一个线程立刻能感知到其修改的值。</p><p>​        这其中涉及到指令重排序，happens-before原则，内存屏障等知识点，马老师的JVM课程均有讲解，这里不重复赘述了。</p><p>​        Go的语言的内存模型要解决的也是这个问题。</p><p>​        简单的来说，Go的语言的内存模型设定是一种处理规则和机制，</p><p>​        这个处理规则和机制规定了在多个协程间(goroutine间)访问一个公有的共享变量时，共享变量被一个goroutine修改后是否可以被另外的goroutine立刻感知到（可见性），或者说在多goroutines下指令如何进行重排序的规则。</p><p>​       Go语言的内存模型第一个是规定了这种共享变量是否可见，什么时候可见的规则，另外就是什么时候会导致多goroutines指令重排序</p><p>会有并发安全问题。Go语言的内存模型是一种规则，如果想要在这个规则上保证Go语言的线程安全性，共享变量可见性，则需要使用Go并发编程包的一系列工具类(结构体)。</p><h4 id="4-Go语言的GC-垃圾回收-算法"><a href="#4-Go语言的GC-垃圾回收-算法" class="headerlink" title="4.Go语言的GC(垃圾回收)算法"></a>4.Go语言的GC(垃圾回收)算法</h4><p>​        Go的垃圾收集算法这个概念强调的是在Go语言为变量分配内存空间后，当这些变量废弃后如何把这块内存重新利用的问题，这个和其它语言中的GC概念也是基本一致的。</p><h3 id="二-我们这篇文档主要讲的是什么内容？"><a href="#二-我们这篇文档主要讲的是什么内容？" class="headerlink" title="二.我们这篇文档主要讲的是什么内容？"></a>二.我们这篇文档主要讲的是什么内容？</h3><p>​        我们这篇文档会讲解Go语言的内存空间是如何按照功能模块划分的，还有就是Go在为变量申请内存空间时的内存分配逻辑，最后再加上Go的GC机制相关的内容。</p><p>​        再次重复，我们讲解的是如下：</p><h4 id="1-Go的内存划分"><a href="#1-Go的内存划分" class="headerlink" title="1.Go的内存划分"></a>1.Go的内存划分</h4><h4 id="2-Go的内存分配机制"><a href="#2-Go的内存分配机制" class="headerlink" title="2.Go的内存分配机制"></a>2.Go的内存分配机制</h4><h4 id="3-Go的GC机制相关内容"><a href="#3-Go的GC机制相关内容" class="headerlink" title="3.Go的GC机制相关内容"></a>3.Go的GC机制相关内容</h4><h3 id="二-Go语言采用了什么内存分配（重点是分配！！）算法？"><a href="#二-Go语言采用了什么内存分配（重点是分配！！）算法？" class="headerlink" title="二.Go语言采用了什么内存分配（重点是分配！！）算法？"></a>二.Go语言采用了什么内存分配（重点是分配！！）算法？</h3><h4 id="Go语言采用了-TCMalloc-算法。"><a href="#Go语言采用了-TCMalloc-算法。" class="headerlink" title="Go语言采用了  TCMalloc 算法。"></a>Go语言采用了  TCMalloc 算法。</h4><p>。。。待补</p><h3 id="三-概述"><a href="#三-概述" class="headerlink" title="三.概述"></a>三.概述</h3><p>Go语言的内存管理是由Go语言自己的一个系统线程处理的，具体申请内存，释放内存垃圾回收等操作逻辑就是用Go自己本身的这个语言写的。</p><p>管理Go内存机制的这块Go语言代码是属于Go的系统库。</p><p>位于${GOPATH}/src/runtime包下</p><p>比如其中有一个核心文件就是${GOPATH}/src/runtime/malloc.go</p><h3 id="四-Go语言的内存管理相关源码是什么语言实现的？"><a href="#四-Go语言的内存管理相关源码是什么语言实现的？" class="headerlink" title="四.Go语言的内存管理相关源码是什么语言实现的？"></a>四.Go语言的内存管理相关源码是什么语言实现的？</h3><p>​    Go在1.10版本之前是用的c语言的代码实现的内存管理机制。</p><p>​    Go在1.10版本之后改变了方式，都是使用的本身自己的Go语言实现的内存管理机制。</p><p>​    </p><p>​    </p><p>三.Go的源码包结构和说明</p><h3 id="五-Go是如何向操作系统申请内存并自己管理的？"><a href="#五-Go是如何向操作系统申请内存并自己管理的？" class="headerlink" title="五.Go是如何向操作系统申请内存并自己管理的？"></a>五.Go是如何向操作系统申请内存并自己管理的？</h3><p>​        在GoSDK1.14版本之后，Go的内存分配机制相关代码完全是由Go自己这门语言编写的了。</p><p>​        也就是说Go从操作系统申请到的内存是自己管理的。</p><p>​        那我们先来问一个问题，比如Go一开始向操作系统申请4G内存，此时你的电脑内存使用量会随之增加4G吗？</p><p>​        比如你电脑16G内存，你运行了Go程序，此时你的电脑剩余可以使用的内存还是16G左右还是少了4G变成12G了？</p><p>​        答案是：你的电脑还是接近16G,启动Go程序的时候并不会真正的消耗和使用掉4G，而是具体的当你Go中的对象和变量逐渐</p><p>增多，你真实使用的内存才会增多。</p><p>​        这是因为操作系统的一个机制，虚拟内存管理机制。</p><p>​        注意，虚拟内存机制是基于操作系统的，面向的是所有在此操作系统上运行的程序。</p><p>​        也就是说，即使你是用的是Java语言开发的程序，你在JVM中设置了-Xms4g,只要你的内存够，就能跑起来，但是不会直接占用你4G的内存，因为JVM也是申请的虚拟内存地址。</p><p>​        那么我们接下来简单讲讲虚拟内存地址是一个怎么样的原理？</p><p>​        要理解虚拟地址，我们首先要问，什么是虚拟地址，它和我们说的物理内存地址有什么区别？</p><p>​        而物理内存地址又和我们的硬件内存条有什么关系？为什么不直接使用物理内存，还要加一个虚拟内存机制的机制？</p><p>​        我们从内存条和物理内存地址讲起：</p><p>​        内存条(比如一般的笔记本都是8G,16G的)的本质是一种存储器，它是用来存储程序在运行时的数据的。</p><p>​        我们做一个比喻：</p><p>​        。。。待补</p><h3 id="六-Go内存中各个模块的划分和功能"><a href="#六-Go内存中各个模块的划分和功能" class="headerlink" title="六.Go内存中各个模块的划分和功能"></a>六.Go内存中各个模块的划分和功能</h3><p>我们先来看一个图，然后看看图的的模块对应下面源码中的哪些变量。</p><p>我们的所有内存管理机制都是通过mheap这个结构体管理的，在下图中Heap实际上指的就是mheap结构体对象，</p><p>我们一定把这张图和下面的代码对着看，一个个变量对照着看才比较好。</p><p>整体结构我先用文字简单概括一下，下面也有图：</p><p>所有的内存管理都在mheap这个结构体中完成。</p><p>mheap(堆结构体)</p><p>​            注意:这里我们先不用理解每个模块是做什么用的，只要知道结构关系就行。、</p><p>​            下面我们会有专门的部分去讲每个模块的作用和各模块之间的关联关系。</p><p>​        成员变量1(一级成员)：模块名(模块名只是便于理解)【spans】，真实代码变量名：【allspans】 ，真实变量类型【 []*mspan 】</p><p>​        成员变量2(一级成员)：模块名：【arena】,真实代码变量名：【arenas】，</p><p>​                                        真实变量类型【[1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena】</p><p>​        成员变量3(一级成员):  模块名【central】，真实代码变量名【central】，真实变量类型：【[numSpanClasses]struct{…}】</p><p><img src="C:/Users/QianMo/Desktop/Go内存机制文档/001.webp"></p><p>下面是go源码的mheap结构，我已经把不重要的删除掉了，只留下了关键的对应图中结构的部分。</p><h4 id="mheap源码数据结构"><a href="#mheap源码数据结构" class="headerlink" title="mheap源码数据结构"></a>mheap源码数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;<br>  <br>   <span class="hljs-comment">//第一模块：这个对应上图中的spans模块</span><br>   allspans []*mspan <span class="hljs-comment">// all spans out there</span><br><br>   <span class="hljs-comment">//第二个模块： </span><br>   <span class="hljs-comment">//64位windows上：一维数组的长度是:1&lt;&lt;6 = 1*2的六次方= 64</span><br>   <span class="hljs-comment">//61位windows上，二维数组的长度是:</span><br>   arenas [<span class="hljs-number">1</span> &lt;&lt; arenaL1Bits]*[<span class="hljs-number">1</span> &lt;&lt; arenaL2Bits]*heapArena<br><br>   <span class="hljs-comment">//第三大模块</span><br>   central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;<br>      mcentral mcentral<br>      pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span><br>   &#125;<br><br>   <span class="hljs-comment">// </span><br>   spanalloc             fixalloc <span class="hljs-comment">// allocator for span*</span><br>   cachealloc            fixalloc <span class="hljs-comment">// allocator for mcache*</span><br>   <br>&#125;   <br></code></pre></td></tr></table></figure><h4 id="heapArena源码数据结构"><a href="#heapArena源码数据结构" class="headerlink" title="heapArena源码数据结构"></a>heapArena源码数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plain">type heapArena struct &#123;<br>   &#x2F;&#x2F; bitmap stores the pointer&#x2F;scalar bitmap for the words in<br>   &#x2F;&#x2F; this arena. See mbitmap.go for a description. Use the<br>   &#x2F;&#x2F; heapBits type to access this.<br>   bitmap [heapArenaBitmapBytes]byte<br><br>   &#x2F;&#x2F; spans maps from virtual address page ID within this arena to *mspan.<br>   &#x2F;&#x2F; For allocated spans, their pages map to the span itself.<br>   &#x2F;&#x2F; For free spans, only the lowest and highest pages map to the span itself.<br>   &#x2F;&#x2F; Internal pages map to an arbitrary span.<br>   &#x2F;&#x2F; For pages that have never been allocated, spans entries are nil.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; Modifications are protected by mheap.lock. Reads can be<br>   &#x2F;&#x2F; performed without locking, but ONLY from indexes that are<br>   &#x2F;&#x2F; known to contain in-use or stack spans. This means there<br>   &#x2F;&#x2F; must not be a safe-point between establishing that an<br>   &#x2F;&#x2F; address is live and looking it up in the spans array.<br>   spans [pagesPerArena]*mspan<br><br>   &#x2F;&#x2F; pageInUse is a bitmap that indicates which spans are in<br>   &#x2F;&#x2F; state mSpanInUse. This bitmap is indexed by page number,<br>   &#x2F;&#x2F; but only the bit corresponding to the first page in each<br>   &#x2F;&#x2F; span is used.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; Reads and writes are atomic.<br>   pageInUse [pagesPerArena &#x2F; 8]uint8<br><br>   &#x2F;&#x2F; pageMarks is a bitmap that indicates which spans have any<br>   &#x2F;&#x2F; marked objects on them. Like pageInUse, only the bit<br>   &#x2F;&#x2F; corresponding to the first page in each span is used.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; Writes are done atomically during marking. Reads are<br>   &#x2F;&#x2F; non-atomic and lock-free since they only occur during<br>   &#x2F;&#x2F; sweeping (and hence never race with writes).<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; This is used to quickly find whole spans that can be freed.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; TODO(austin): It would be nice if this was uint64 for<br>   &#x2F;&#x2F; faster scanning, but we don&#39;t have 64-bit atomic bit<br>   &#x2F;&#x2F; operations.<br>   pageMarks [pagesPerArena &#x2F; 8]uint8<br><br>   &#x2F;&#x2F; zeroedBase marks the first byte of the first page in this<br>   &#x2F;&#x2F; arena which hasn&#39;t been used yet and is therefore already<br>   &#x2F;&#x2F; zero. zeroedBase is relative to the arena base.<br>   &#x2F;&#x2F; Increases monotonically until it hits heapArenaBytes.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; This field is sufficient to determine if an allocation<br>   &#x2F;&#x2F; needs to be zeroed because the page allocator follows an<br>   &#x2F;&#x2F; address-ordered first-fit policy.<br>   &#x2F;&#x2F;<br>   &#x2F;&#x2F; Read atomically and written with an atomic CAS.<br>   zeroedBase uintptr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="七-Go内存管理机制的组件概念"><a href="#七-Go内存管理机制的组件概念" class="headerlink" title="七.Go内存管理机制的组件概念"></a>七.Go内存管理机制的组件概念</h3><h4 id="1-Go语言的内存容器有三大组件："><a href="#1-Go语言的内存容器有三大组件：" class="headerlink" title="1.Go语言的内存容器有三大组件："></a>1.Go语言的内存容器有三大组件：</h4><p>分别是mheap堆组件，mcentral组件，mcache组件。</p><p><img src="C:/Users/QianMo/Desktop/Go内存机制文档/001.webp"></p><h4 id="mheap"><a href="#mheap" class="headerlink" title="mheap:"></a>mheap:</h4><p>​        mheap是最外层内存容器，它包含着mcentral内存组件和mcache内存组件</p><p>​        具体体现为mheap有那两个组件的成员变量。</p><h4 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral:"></a>mcentral:</h4><p>​        在mheap中有一个mcentral数组(后面有源码)，数组长度是67，每一个mcentral中存储的单个对象大小不同，按单个对象大小不同分为67个mcentral(对象大小问题和内存分配的关系一会第三章有讲）</p><h4 id="mcache"><a href="#mcache" class="headerlink" title="mcache:"></a>mcache:</h4><p>​        go语言中mcache的概念和Java JVM中的栈内存类似，每启动一个线程对应一个mcache内存空间。</p><p>​        mcentral和mheap是所有线程共享的内存空间</p><p>这三个内存容器组成了一个三级缓存的内存申请架构。</p><p>大对象(超过32k,为啥是32k后面有)，直接在mheap中申请内存。</p><p>小对象，先在mcache中申请，没有的话从mcentral拿来一些内存放到mcache中，然后放入mcache,如果mcache存放的过多了，会把一部分迁移到mcentral中，如果mcentral过多了，会迁移到mheap中，最后还不够会通过mheap向操作系统申请内存。</p><hr><h4 id="2-Go语言中的对象是存储在什么结构中的？"><a href="#2-Go语言中的对象是存储在什么结构中的？" class="headerlink" title="2.Go语言中的对象是存储在什么结构中的？"></a>2.Go语言中的对象是存储在什么结构中的？</h4><p>Go语言中有一个组件，叫做mspan,这个mspan在mheap,mcentral,mcache中的成员变量都能找到，</p><p>mspan可以存储大对象，也可以存储小对象。</p><p>mspan是存储数据的最基本类，它存储数据的原理是：</p><p>mspan被赋予了一块连续的内存空间，然后mspan这个结构体(类)它有有四个比较重要成员属性，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;uintptr是一个数值类型，存储的是一个指针地址<br>&#x2F;&#x2F;startAddr代表的是这个mspan的起始内存地址是多少<br>startAddr uintptr<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;mspan虚拟出一个page的角色，实际上没有这个结构体，只是虚拟抽象概念<br>&#x2F;&#x2F;它想实现的一种存储结构类似于    mspan上有多个页page,每个页上有多个obj对象<br>npages    uintptr <br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Object n starts at address n*elemsize + (start &lt;&lt; pageShift).<br>&#x2F;&#x2F;实际上访问的时候只需要算出是第几个对象*单个对象占内存空间大小+mspan起始偏移量即可算出下一个对象应该放到哪里。<br>freeindex uintptr<br>&#x2F;&#x2F; TODO: Look up nelems from sizeclass and remove this field if it<br>&#x2F;&#x2F; helps performance.<br>&#x2F;&#x2F;这个mspan放入了多少个对象，就是上上面的Object n的个数<br>nelems uintptr &#x2F;&#x2F; number of object in the span.<br></code></pre></td></tr></table></figure><p>所以根据上面我们可以看出来，数据是存储在mspan中的，然后mspan记录了它自己的起始内存地址，存储了多个个对象之类的，每个对象多大，然后通过这些一算就能算出来下一个要放在哪个位置上。</p><h3 id="八-Go中大小对象的概念"><a href="#八-Go中大小对象的概念" class="headerlink" title="八.Go中大小对象的概念"></a>八.Go中大小对象的概念</h3><h4 id="1-go语言中的小对象是什么意思？"><a href="#1-go语言中的小对象是什么意思？" class="headerlink" title="1.go语言中的小对象是什么意思？"></a>1.go语言中的小对象是什么意思？</h4><p>​        小于等于32k的对象就是小对象。</p><h4 id="2-go语言中的大对象？"><a href="#2-go语言中的大对象？" class="headerlink" title="2.go语言中的大对象？"></a>2.go语言中的大对象？</h4><p>​        大于32k的对象都是大对象</p><h4 id="3-对象大小和内存分配有什么关系？"><a href="#3-对象大小和内存分配有什么关系？" class="headerlink" title="3.对象大小和内存分配有什么关系？"></a>3.对象大小和内存分配有什么关系？</h4><p>​        go语言中很奇葩，它内部内存申请机制，是根据申请对象所占内存空间大小来区分具体放入到哪个结构体对象中的。</p><p>​       比如，有个分类属性，sizeclass,这个属性是一个int值，从0-66，一共67个数，代表了67类不同内存大小的对象(单个对象占用)。</p><p>​        下面有表格，可以详细看数据。</p><p>​        它mcentral组件和mache组件中存储数据的mspan,都和67有关，也就是说，小对象上来判断你的所申请的内存在0-32k中的哪一个区间，然后给你放入匹配的对应那个mspan中去，不同的mspan结构体对象，里面存储的单个对象内存块大小不同。</p><p>​        不管是这三个内存组件的哪一个，一般存储都是用67个mspan，每个mspan代表了只装这一种内存大小的对象，然后mspan是一个双向链表，不够了往后添加就行。    </p><p>​        go语言中分配内存的机制，首先要根据申请对象所占内存空间的大小来决定，如果是小对象(小于等于32k)，走的是三级缓存的内存管理机制(先从mcache申请，没有再从mcentral申请，最后还不够放入mheap中)，如果是大对象，会直接会向堆申请内存空间(具体细节后面详细讲)</p><p>​        这样区分对象大小来分配内存有两个好处：    </p><p>​         1).减少内存碎片。</p><p>​         2).便于管理，提高内存分配和释放的速度。</p><h4 id="4-go语言中大对象如何分配内存？"><a href="#4-go语言中大对象如何分配内存？" class="headerlink" title="4.go语言中大对象如何分配内存？"></a>4.go语言中大对象如何分配内存？</h4><p>​        go语言中超过32k的对象都是大对象，大对象的类型编号classsize(这个编号用于表示不同的对象占用内存大小)为0，会直接从mheap(后面详细讲mheap)中申请内存空间，会把数据存储在mheap的成员变量allspans中，后面源码能看到那个成员变量，不会经过mcache组件和mcentral组件。</p><h4 id="5-go语言中小对象如何申请内存？"><a href="#5-go语言中小对象如何申请内存？" class="headerlink" title="5.go语言中小对象如何申请内存？"></a>5.go语言中小对象如何申请内存？</h4><p>​        go语言中小对象是指小于32k的对象，go会先判断要申请的小对象的大小，然后根据下面的这张表找到对应的class编号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">const (<br>   _MaxSmallSize   &#x3D; 32768<br>   smallSizeDiv    &#x3D; 8<br>   smallSizeMax    &#x3D; 1024<br>   largeSizeDiv    &#x3D; 128<br>&#x2F;&#x2F; class  bytes&#x2F;obj  bytes&#x2F;span  objects  tail waste  max waste<br>   &#x2F;&#x2F;表示在新创建对象时，按照对象占用内存空间的大小，可以在67种不同的内存大小分类(按单个对象所占大小分类，看下面表格)中挑选一个    &#x2F;&#x2F;最合适的，最大的对象在go语言中也归类为小对象，最大的小对象32k。<br>   _NumSizeClasses &#x3D; 67<br>   _PageShift      &#x3D; 13<br>)<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs plain">说明一下span和对象(obj)的关系<br>我们在go中如何创建一个对象，或者一个变量都是叫做一个obj,也就是下面的第二列。<br>而我们的多个obj是装在一个span中管理的，span是一个容器，装着多个obj对象，<br>class是一个类型的型号编码，这个类型型号中的类型是按一个对象(obj)占用内存的大小来区分的，也就是<br>不同的class对应的obj所申请占用的一块内存空间大小不一样，第四列是objects，代表一个span能装多少个obj，objects是一个数量，<br>第五列是指内存浪费的字节，也就是看下下面的公式：<br>一个对象占的字节数*对象个数+不连续的小碎片浪费的内存空间&#x3D;一个span的空间大小<br>obj(bytes)*objects+tail waste(bytes) &#x3D; span(bytes)<br>注意，我们就是从这张表中得知go语言中的大对象和小对象是如何划分的，<br>拉到这张标的最后面，一个对象的最大字节数是32768bytes<br>而我们计算一下32768&#x2F;1024&#x3D;32(KB)<br>所以Go语言中的67种对象大小分类中，最大的也就是32k,这也可以验证了<br>超过32k的大对象是不会走mcahe和central这两个内存容器的，直接会在mheap中申请内存<br>&#x2F;&#x2F;  7   10   50<br> 7     7   7<br>7+1&#x3D;8     10-8 &#x3D; 2 *  <br>&#x2F;&#x2F; class  bytes&#x2F;obj  bytes&#x2F;span  objects  tail waste  max waste<br>&#x2F;&#x2F;     1          8        8192(8M)     1024           0     87.50%<br><br>7*1024 &#x3D; 7168<br>7168 &#x2F; 8192 &#x3D; 87.50%<br><br>(((objsize-real_objsize) * objects)+tail_waste) &#x2F;spansize<br><br>&#x2F;&#x2F;     2         16        8192      512           0     43.75%<br>&#x2F;&#x2F;     3         32        8192      256           0     46.88%<br>&#x2F;&#x2F;     4         48        8192      170          32     31.52%<br><br>((c.size - (preSize+1)) * objects + tailWaste) &#x2F; spanSize<br>((48-(32+1)*170)*170+32 )&#x2F;8192<br>&#x2F;&#x2F;     5         64        8192      128           0     23.44%<br>&#x2F;&#x2F;     6         80        8192      102          32     19.07%<br>&#x2F;&#x2F;     7         96        8192       85          32     15.95%<br>&#x2F;&#x2F;     8        112        8192       73          16     13.56%<br>&#x2F;&#x2F;     9        128        8192       64           0     11.72%<br>&#x2F;&#x2F;    10        144        8192       56         128     11.82%<br>&#x2F;&#x2F;    11        160        8192       51          32      9.73%<br>&#x2F;&#x2F;    12        176        8192       46          96      9.59%<br>&#x2F;&#x2F;    13        192        8192       42         128      9.25%<br>&#x2F;&#x2F;    14        208        8192       39          80      8.12%<br>&#x2F;&#x2F;    15        224        8192       36         128      8.15%<br>&#x2F;&#x2F;    16        240        8192       34          32      6.62%<br>&#x2F;&#x2F;    17        256        8192       32           0      5.86%<br>&#x2F;&#x2F;    18        288        8192       28         128     12.16%<br>&#x2F;&#x2F;    19        320        8192       25         192     11.80%<br>&#x2F;&#x2F;    20        352        8192       23          96      9.88%<br>&#x2F;&#x2F;    21        384        8192       21         128      9.51%<br>&#x2F;&#x2F;    22        416        8192       19         288     10.71%<br>&#x2F;&#x2F;    23        448        8192       18         128      8.37%<br>&#x2F;&#x2F;    24        480        8192       17          32      6.82%<br>&#x2F;&#x2F;    25        512        8192       16           0      6.05%<br>&#x2F;&#x2F;    26        576        8192       14         128     12.33%<br>&#x2F;&#x2F;    27        640        8192       12         512     15.48%<br>&#x2F;&#x2F;    28        704        8192       11         448     13.93%<br>&#x2F;&#x2F;    29        768        8192       10         512     13.94%<br>&#x2F;&#x2F;    30        896        8192        9         128     15.52%<br>&#x2F;&#x2F;    31       1024        8192        8           0     12.40%<br>&#x2F;&#x2F;    32       1152        8192        7         128     12.41%<br>&#x2F;&#x2F;    33       1280        8192        6         512     15.55%<br>&#x2F;&#x2F;    34       1408       16384       11         896     14.00%<br>&#x2F;&#x2F;    35       1536        8192        5         512     14.00%<br>&#x2F;&#x2F;    36       1792       16384        9         256     15.57%<br>&#x2F;&#x2F;    37       2048        8192        4           0     12.45%<br>&#x2F;&#x2F;    38       2304       16384        7         256     12.46%<br>&#x2F;&#x2F;    39       2688        8192        3         128     15.59%<br>&#x2F;&#x2F;    40       3072       24576        8           0     12.47%<br>&#x2F;&#x2F;    41       3200       16384        5         384      6.22%<br>&#x2F;&#x2F;    42       3456       24576        7         384      8.83%<br>&#x2F;&#x2F;    43       4096        8192        2           0     15.60%<br>&#x2F;&#x2F;    44       4864       24576        5         256     16.65%<br>&#x2F;&#x2F;    45       5376       16384        3         256     10.92%<br>&#x2F;&#x2F;    46       6144       24576        4           0     12.48%<br>&#x2F;&#x2F;    47       6528       32768        5         128      6.23%<br>&#x2F;&#x2F;    48       6784       40960        6         256      4.36%<br>&#x2F;&#x2F;    49       6912       49152        7         768      3.37%<br>&#x2F;&#x2F;    50       8192        8192        1           0     15.61%<br>&#x2F;&#x2F;    51       9472       57344        6         512     14.28%<br>&#x2F;&#x2F;    52       9728       49152        5         512      3.64%<br>&#x2F;&#x2F;    53      10240       40960        4           0      4.99%<br>&#x2F;&#x2F;    54      10880       32768        3         128      6.24%<br>&#x2F;&#x2F;    55      12288       24576        2           0     11.45%<br>&#x2F;&#x2F;    56      13568       40960        3         256      9.99%<br>&#x2F;&#x2F;    57      14336       57344        4           0      5.35%<br>&#x2F;&#x2F;    58      16384       16384        1           0     12.49%<br>&#x2F;&#x2F;    59      18432       73728        4           0     11.11%<br>&#x2F;&#x2F;    60      19072       57344        3         128      3.57%<br>&#x2F;&#x2F;    61      20480       40960        2           0      6.87%<br>&#x2F;&#x2F;    62      21760       65536        3         256      6.25%<br>&#x2F;&#x2F;    63      24576       24576        1           0     11.45%<br>&#x2F;&#x2F;    64      27264       81920        3         128     10.00%<br>&#x2F;&#x2F;    65      28672       57344        2           0      4.91%<br>&#x2F;&#x2F;    66      32768       32768        1           0     12.50%<br></code></pre></td></tr></table></figure><h3 id="九-源码数据结构"><a href="#九-源码数据结构" class="headerlink" title="九.源码数据结构"></a>九.源码数据结构</h3><h4 id="1-mheap结构体"><a href="#1-mheap结构体" class="headerlink" title="1.mheap结构体"></a>1.mheap结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;<br><br>   <span class="hljs-comment">//这个对象数组是mheap中自己管理的内存容器</span><br>   allspans []*mspan <span class="hljs-comment">// all spans out there</span><br><br>   <br>   <span class="hljs-comment">//areans这个变量 存储着一些位图信息，位图信息用于垃圾收集时标记清楚。。。</span><br>   arenas [<span class="hljs-number">1</span> &lt;&lt; arenaL1Bits]*[<span class="hljs-number">1</span> &lt;&lt; arenaL2Bits]*heapArena<br><br><br>   <span class="hljs-comment">//重点！！！！！</span><br>   <span class="hljs-comment">//central数组对象是一个重要的容器</span><br>   <span class="hljs-comment">//central的本质时一个匿名的结构体数组</span><br>   <span class="hljs-comment">//这个写法声明一个匿名结构体数组变量，变量名为central</span><br>   central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;<br>     <span class="hljs-comment">//这个是具体的类，里面有mspan数组，再里面存储数据</span><br>      mcentral mcentral<br>      pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span><br>   &#125;<br><br>   spanalloc             fixalloc <span class="hljs-comment">// allocator for span*</span><br>   cachealloc            fixalloc <span class="hljs-comment">// allocator for mcache*</span><br>   specialfinalizeralloc fixalloc <span class="hljs-comment">// allocator for specialfinalizer*</span><br>   specialprofilealloc   fixalloc <span class="hljs-comment">// allocator for specialprofile*</span><br>   speciallock           mutex    <span class="hljs-comment">// lock for special record allocators.</span><br>   arenaHintAlloc        fixalloc <span class="hljs-comment">// allocator for arenaHints</span><br><br>   unused *specialfinalizer <span class="hljs-comment">// never set, just here to force the specialfinalizer type into DWARF</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-核心mcentral"><a href="#2-核心mcentral" class="headerlink" title="2.核心mcentral"></a>2.核心mcentral</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcentral <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">//真正存储数据的mspan,mSpanList里头是mspan</span><br>   <span class="hljs-comment">//这两个配合存储数据(这个详细的区别说明下次加上)</span><br>   nonempty  mSpanList <span class="hljs-comment">// list of spans with a free object, ie a nonempty free list</span><br>   empty     mSpanList <span class="hljs-comment">// list of spans with no free objects (or cached in an mcache)</span><br><br>   <span class="hljs-comment">// nmalloc is the cumulative count of objects allocated from</span><br>   <span class="hljs-comment">// this mcentral, assuming all spans in mcaches are</span><br>   <span class="hljs-comment">// fully-allocated. Written atomically, read under STW.</span><br>   nmalloc <span class="hljs-keyword">uint64</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-mSpanList-装着多个span的列表结构体"><a href="#3-mSpanList-装着多个span的列表结构体" class="headerlink" title="3.mSpanList(装着多个span的列表结构体)"></a>3.mSpanList(装着多个span的列表结构体)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mSpanList <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">//头节点mspan(引用类型)</span><br>   first *mspan <span class="hljs-comment">// first span in list, or nil if none</span><br>   <span class="hljs-comment">//尾部节点mspan(引用类型)</span><br>   last  *mspan <span class="hljs-comment">// last span in list, or nil if none</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-mspan-正真存储数据的结构体，类"><a href="#4-mspan-正真存储数据的结构体，类" class="headerlink" title="4.mspan(正真存储数据的结构体，类)"></a>4.mspan(正真存储数据的结构体，类)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//mspan是一个双向链表结构</span><br><span class="hljs-keyword">type</span> mspan <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">//下一个span节点  如果空的话填none</span><br>   next *mspan     <span class="hljs-comment">// next span in list, or nil if none</span><br>   <span class="hljs-comment">//上一个span节点 如果空的话填none</span><br>   prev *mspan     <span class="hljs-comment">// previous span in list, or nil if none</span><br>   list *mSpanList <span class="hljs-comment">// For debugging. <span class="hljs-doctag">TODO:</span> Remove.</span><br><br>   <span class="hljs-comment">//当前span的起始内存地址</span><br>   startAddr <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// address of first byte of span aka s.base()</span><br>   <span class="hljs-comment">//当前的span有几页数据</span><br>   <span class="hljs-comment">//一个span有多个page</span><br>   npages    <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of pages in span</span><br><br>   manualFreeList gclinkptr <span class="hljs-comment">// list of free objects in mSpanManual spans</span><br><br>   <span class="hljs-comment">// freeindex is the slot index between 0 and nelems at which to begin scanning</span><br>   <span class="hljs-comment">// for the next free object in this span.</span><br>   <span class="hljs-comment">// Each allocation scans allocBits starting at freeindex until it encounters a 0</span><br>   <span class="hljs-comment">// indicating a free object. freeindex is then adjusted so that subsequent scans begin</span><br>   <span class="hljs-comment">// just past the newly discovered free object.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// If freeindex == nelem, this span has no free objects.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// allocBits is a bitmap of objects in this span.</span><br>   <span class="hljs-comment">// If n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0</span><br>   <span class="hljs-comment">// then object n is free;</span><br>   <span class="hljs-comment">// otherwise, object n is allocated. Bits starting at nelem are</span><br>   <span class="hljs-comment">// undefined and should never be referenced.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// Object n starts at address n*elemsize + (start &lt;&lt; pageShift).</span><br>   freeindex <span class="hljs-keyword">uintptr</span><br>   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Look up nelems from sizeclass and remove this field if it</span><br>   <span class="hljs-comment">// helps performance.</span><br>   nelems <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// number of object in the span.</span><br><br>   <span class="hljs-comment">// Cache of the allocBits at freeindex. allocCache is shifted</span><br>   <span class="hljs-comment">// such that the lowest bit corresponds to the bit freeindex.</span><br>   <span class="hljs-comment">// allocCache holds the complement of allocBits, thus allowing</span><br>   <span class="hljs-comment">// ctz (count trailing zero) to use it directly.</span><br>   <span class="hljs-comment">// allocCache may contain bits beyond s.nelems; the caller must ignore</span><br>   <span class="hljs-comment">// these.</span><br>   allocCache <span class="hljs-keyword">uint64</span><br><br>   <span class="hljs-comment">// allocBits and gcmarkBits hold pointers to a span&#x27;s mark and</span><br>   <span class="hljs-comment">// allocation bits. The pointers are 8 byte aligned.</span><br>   <span class="hljs-comment">// There are three arenas where this data is held.</span><br>   <span class="hljs-comment">// free: Dirty arenas that are no longer accessed</span><br>   <span class="hljs-comment">//       and can be reused.</span><br>   <span class="hljs-comment">// next: Holds information to be used in the next GC cycle.</span><br>   <span class="hljs-comment">// current: Information being used during this GC cycle.</span><br>   <span class="hljs-comment">// previous: Information being used during the last GC cycle.</span><br>   <span class="hljs-comment">// A new GC cycle starts with the call to finishsweep_m.</span><br>   <span class="hljs-comment">// finishsweep_m moves the previous arena to the free arena,</span><br>   <span class="hljs-comment">// the current arena to the previous arena, and</span><br>   <span class="hljs-comment">// the next arena to the current arena.</span><br>   <span class="hljs-comment">// The next arena is populated as the spans request</span><br>   <span class="hljs-comment">// memory to hold gcmarkBits for the next GC cycle as well</span><br>   <span class="hljs-comment">// as allocBits for newly allocated spans.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// The pointer arithmetic is done &quot;by hand&quot; instead of using</span><br>   <span class="hljs-comment">// arrays to avoid bounds checks along critical performance</span><br>   <span class="hljs-comment">// paths.</span><br>   <span class="hljs-comment">// The sweep will free the old allocBits and set allocBits to the</span><br>   <span class="hljs-comment">// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed</span><br>   <span class="hljs-comment">// out memory.</span><br>   allocBits  *gcBits<br>   gcmarkBits *gcBits<br><br>   <span class="hljs-comment">// sweep generation:</span><br>   <span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping</span><br>   <span class="hljs-comment">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept</span><br>   <span class="hljs-comment">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use</span><br>   <span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping</span><br>   <span class="hljs-comment">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached</span><br>   <span class="hljs-comment">// h-&gt;sweepgen is incremented by 2 after every GC</span><br><br>   sweepgen    <span class="hljs-keyword">uint32</span><br>   divMul      <span class="hljs-keyword">uint16</span>        <span class="hljs-comment">// for divide by elemsize - divMagic.mul</span><br>   baseMask    <span class="hljs-keyword">uint16</span>        <span class="hljs-comment">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base</span><br>   allocCount  <span class="hljs-keyword">uint16</span>        <span class="hljs-comment">// number of allocated objects</span><br>   <span class="hljs-comment">//当前span的sizeclass，也就是大小类型，必然是67种的一种</span><br>   spanclass   spanClass     <span class="hljs-comment">// size class and noscan (uint8)</span><br>   state       mSpanStateBox <span class="hljs-comment">// mSpanInUse etc; accessed atomically (get/set methods)</span><br>   needzero    <span class="hljs-keyword">uint8</span>         <span class="hljs-comment">// needs to be zeroed before allocation</span><br>   divShift    <span class="hljs-keyword">uint8</span>         <span class="hljs-comment">// for divide by elemsize - divMagic.shift</span><br>   divShift2   <span class="hljs-keyword">uint8</span>         <span class="hljs-comment">// for divide by elemsize - divMagic.shift2</span><br>   elemsize    <span class="hljs-keyword">uintptr</span>       <span class="hljs-comment">// computed from sizeclass or from npages</span><br>   limit       <span class="hljs-keyword">uintptr</span>       <span class="hljs-comment">// end of data in span</span><br>   speciallock mutex         <span class="hljs-comment">// guards specials list</span><br>   specials    *special      <span class="hljs-comment">// linked list of special records sorted by offset.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="十-初始化流程"><a href="#十-初始化流程" class="headerlink" title="十.初始化流程"></a>十.初始化流程</h3><p>首先列一个层级架构:</p><p>​            1.最底层mheap(和操作系统内存打交道)</p><p>​                    mheap中包含着mache组件和mcentral组件</p><p>​                    mheap向操作系统申请内存空间，然后分配给mcentral</p><p>​            2.第二级mcentral组件</p><p>​            3.第一级mcache组件(小对象最优先看这个可不可以申请内存)        </p><p>Go会在程序运行时调用一个内存管理初始化的函数mallocinit</p><p>如下：</p><p>在这个方法中会初始化堆组件(堆组件结构体名称叫mheap)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocinit</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">// Initialize the heap.</span><br><span class="hljs-comment">//初始化堆  注意：对象变量名叫mheap_，结构体类型定义是mheap</span><br>mheap_.init()<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//初始化核心组件mcache</span><br>_g_.m.mcache = allocmcache()<br><span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来一切都要围绕着这个mheap堆组件来展开了</p><p>我们来看看这个mheap结构体里面的关键组成部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//一.mheap管理的重要内存组件！！！！！</span><br><span class="hljs-comment">//mheap堆自己管理的容器组件，大对象申请直接放到这里，mcache和mcentral中的对象过多也会迁移到这里一部分</span><br>allspans []*mspan <span class="hljs-comment">// all spans out there</span><br><br><span class="hljs-comment">//二.重点！！！！核心内存组件二 central </span><br>central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;<br>mcentral mcentral<br>pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span><br>&#125;<br><br><span class="hljs-comment">//span分配器，用于申请内存创建span容器</span><br>spanalloc       fixalloc <span class="hljs-comment">// allocator for span*</span><br><br><span class="hljs-comment">//三.内存容器组件三是mcache，只不过在别处通过cachealloc分配器进行创建的</span><br><span class="hljs-comment">//mcache分配器，用于创建mcache，只不过在别处创建的组件</span><br>mcachealloc      fixalloc <span class="hljs-comment">// allocator for mcache*</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在下面这里才初始化了mcache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Initialize the heap.<br>mheap_.init()<br>_g_ :&#x3D; getg()<br>&#x2F;&#x2F;这一步骤真正的初始化了Cache内存组件<br>_g_.m.mcache &#x3D; allocmcache()<br></code></pre></td></tr></table></figure><p>我们看看它内部是如何实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// dummy mspan that contains no free objects.</span><br><span class="hljs-comment">//空的mspan容器，回忆一下，真正的对象是存储在哪里？</span><br><span class="hljs-comment">//mspan---&gt;page----&gt;obj</span><br><span class="hljs-keyword">var</span> emptymspan mspan<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocmcache</span><span class="hljs-params">()</span> *<span class="hljs-title">mcache</span></span> &#123;<br>   <span class="hljs-keyword">var</span> c *mcache<br>   systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      lock(&amp;mheap_.lock)<br>      <span class="hljs-comment">//1.核心步骤(1)调用alloc方法创建*mcache指针对象</span><br>      c = (*mcache)(mheap_.cachealloc.alloc())<br>      c.flushGen = mheap_.sweepgen<br>      unlock(&amp;mheap_.lock)<br>   &#125;)<br>   <span class="hljs-comment">//2.核心步骤(2)</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> c.alloc &#123;<br>     <span class="hljs-comment">//为c(这个c就是mcache组件)分配控的mspan,这样之后数据装入mspan中就可以了 </span><br>      c.alloc[i] = &amp;emptymspan<br>   &#125;<br>   <span class="hljs-comment">//这里瞄了一眼，类似于递归</span><br>   c.next_sample = nextSample()<br>   <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>核心组件mcache(每个线程都有一个)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span> &#123;<br>  <br>   <span class="hljs-comment">// The rest is not accessed on every malloc.</span><br>   <span class="hljs-comment">//重点看这里！！！！！</span><br>   <span class="hljs-comment">//mcahe这个组件中的数据都存在这里！！！！   存在这个长度为67的mspan数组中</span><br>   <span class="hljs-comment">//存储数据的时候先根据对象申请的内存大小匹配到67个mspan中的合适大小的那个mspan，然后mspan是个链表，</span><br>   <span class="hljs-comment">//在mspan链表后添加一个mspan,把数据存进去即可，记住mcache这个结构体中的都是存储的小对象</span><br>   <span class="hljs-comment">//numSpanClasses=67,每个代表一个size大小类型，参考前面的size表格</span><br>   alloc [numSpanClasses]*mspan <span class="hljs-comment">// spans to allocate from, indexed by spanClass</span><br>&#125;<br></code></pre></td></tr></table></figure><p>go语言中cache的概念和Java JVM中的栈内存类似，每启动一个线程对应一个cache，</p><p>Central和Heap是所有线程共享的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Initialize the heap.</span><br><span class="hljs-comment">//初始化mheap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *mheap)</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//spanalloc是一个span内存管理分配器，调用spanalloc的init方法初始化hmeap中的allspans([]mspan类型)数组</span><br>   <span class="hljs-comment">//allspans([]mspan类型)数组实质上就是hmeap的内存容器，大对象都是存储在这里的，cache和central中的小对象太多了的时候</span><br>   <span class="hljs-comment">//也会把一部分迁移到allspans([]mspan类型)这个内存容器当中</span><br>   h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)<br>   h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, &amp;memstats.mcache_sys)<br>   h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, &amp;memstats.other_sys)<br>   h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, &amp;memstats.other_sys)<br>   h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, &amp;memstats.other_sys)<br><br>   <span class="hljs-comment">// Don&#x27;t zero mspan allocations. Background sweeping can</span><br>   <span class="hljs-comment">// inspect a span concurrently with allocating it, so it&#x27;s</span><br>   <span class="hljs-comment">// important that the span&#x27;s sweepgen survive across freeing</span><br>   <span class="hljs-comment">// and re-allocating a span to prevent background sweeping</span><br>   <span class="hljs-comment">// from improperly cas&#x27;ing it from 0.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// This is safe because mspan contains no heap pointers.</span><br>   h.spanalloc.zero = <span class="hljs-literal">false</span><br><br>   <span class="hljs-comment">// h-&gt;mapcache needs no init</span><br><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> h.central &#123;<br>      h.central[i].mcentral.init(spanClass(i))<br>   &#125;<br><br>   h.pages.init(&amp;h.lock, &amp;memstats.gc_sys)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="十一-详解Go执行流程"><a href="#十一-详解Go执行流程" class="headerlink" title="十一.详解Go执行流程"></a>十一.详解Go执行流程</h3><p>我们要想运行一个Go的程序，有两种方式：</p><p>​            1.在我们开发的时候，我们自己用go run  go程序文件运行go程序。</p><p>​            2.我们可以把Go程序编译成一个二进制的可执行程序，然后在对应的电脑上直接运行。</p><p>​            那其中里面到底是怎么一个流程呢?</p><p>​            实际上，在windows平台，比如第一种，在你用go run运行你的go程序的时候，真正先执行的是go.exe这个二进制文件，你的后面传的程序文件名路径只是作为go.exe 的其中一个参数。</p><p>​            也就是说，它是怎么调用你的main函数的呢？因为是执行go.exe，所以他可以这样：</p><p>​    (下面为了便于理解，大大的简化了复杂的流程和细节，想看细节的话可以往后面翻)</p><p>​        1).go.exe ：(go.exe是一个二进制程序，它的源码包含两部分，一部分是.s结尾的汇编程序文件，一部分是.go结尾的go自身SDK源码程序文件，最后这两种会打包成go.exe一个二进制文件) </p><p>​            go.exe开始的汇编代码块会执行一些go系统逻辑，比如向操作系统申请一块虚拟内存地址，比如创建建GMP模型中的p结构体对象，m结构体对象，创建一个g结构体对象，这个g结构体对象是一个main  goroutine,然后再 main goroutine 中调用runtime.main,之后进行一些列操作等等。</p><p>​        2).然后初始化好了，会开始取出你的程序，找到你的main包main函数，调用一下。</p><p>​        这样你就感觉好像是直接运行了你自己的go程序main函数一样。</p><p>​        如果不是用go.exe运行呢？直接把程序编译成二进制文件呢？</p><p>​        实际上是一样的，只不过这个时候它把go.exe中的逻辑和你的程序拼接在一起打了一个二进制包，实际上本质上和第一种用go.exe的方式运行go程序是一样的。</p><p>​    。。。待补    </p><p>​        在初始化过程中我们要梳理清楚一个大体的调用关系：</p><p>​        1.上面在我们的go.exe程序执行的时候，它实际上首先运行的是汇编语言的代码：</p><p>​               (这里我们简单讲一下，在GoSDK的源码包中，实际上关于启动Go程序的汇编程序有好多个，电脑在真正运行的时候只会根据当前系统的cpu判断出使用哪一种汇编语言指令集(我们可以简单粗糙的理解为每种cpu对应一种汇编语言，每种汇编语言写法有些小小区别，要想要cpu能执行我们的汇编代码，得用其cpu型号对应支持能识别的汇编语言编写才行)，然后启动对应汇编指令的一个Go程序启动方法）</p><p>​            比如我们看看这个asm_amd64.s文件，这是一个汇编源码文件：            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;导入包...<br>#include &quot;go_asm.h&quot;<br>#include &quot;go_tls.h&quot;<br>#include &quot;funcdata.h&quot;<br>#include &quot;textflag.h&quot;<br>&#x2F;&#x2F;程序启动<br>&#x2F;&#x2F;注意下面 runtime是哪里来的？上面include包中带的，<br>&#x2F;&#x2F;TEXT是什么？ 在汇编语言中TEXT后面代表可执行代码<br>&#x2F;&#x2F;rt0_go这个方法就是Go程序真正的启动入口<br>TEXT runtime·rt0_go(SB),NOSPLIT,$0<br>   &#x2F;&#x2F; copy arguments forward on an even stack<br>   MOVQ   DI, AX    &#x2F;&#x2F; argc<br>   MOVQ   SI, BX    &#x2F;&#x2F; argv<br>   SUBQ   $(4*8+7), SP      &#x2F;&#x2F; 2args 2auto<br>   ANDQ   $~15, SP<br>   MOVQ   AX, 16(SP)<br>   MOVQ   BX, 24(SP)<br>   <br>   &#x2F;&#x2F; create istack out of the given (operating system) stack.<br>   &#x2F;&#x2F; _cgo_init may update stackguard.<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go内存管理机制&quot;&gt;&lt;a href=&quot;#Go内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;Go内存管理机制&quot;&gt;&lt;/a&gt;Go内存管理机制&lt;/h2&gt;&lt;h3 id=&quot;一-关于Go语言内存机制相关的概念&quot;&gt;&lt;a href=&quot;#一-关于Go语言内存机制</summary>
      
    
    
    
    
    <category term="go" scheme="https://qianmo.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>1.Go与Java</title>
    <link href="https://qianmo.github.io/2021/04/03/go/01-Go%E4%B8%8EJava/"/>
    <id>https://qianmo.github.io/2021/04/03/go/01-Go%E4%B8%8EJava/</id>
    <published>2021-04-03T05:58:11.000Z</published>
    <updated>2021-04-11T07:04:08.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go与Java"><a href="#Go与Java" class="headerlink" title="Go与Java"></a>Go与Java</h1><h3 id="零-GoApi文档和中文社区网址"><a href="#零-GoApi文档和中文社区网址" class="headerlink" title="零.GoApi文档和中文社区网址"></a>零.GoApi文档和中文社区网址</h3><p>Go的中文api文档：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p>Go中文社区网站：<a href="https://studygolang.com/">https://studygolang.com/</a></p> <span id="more"></span>  <h2 id="一-关于Java"><a href="#一-关于Java" class="headerlink" title="一.关于Java"></a>一.关于Java</h2><h3 id="1-Java的用途"><a href="#1-Java的用途" class="headerlink" title="1.Java的用途"></a>1.Java的用途</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">首先我们来回顾下Java的主要用途和应用场景：<br>   用途一：服务器后端系统开发(web后端、微服务后端支付系统、业务系统、管理后台，各种后台交互的接口服务)。<br>   用途二：大数据框架的底层实现和Java的API支持。(Hadoop)。<br>   用途三：其它中间件的底层开发。(Tomcat、RocketMq、Hbase、Kafka(部分)、SpringCloud，Dubbo...)。<br></code></pre></td></tr></table></figure><h3 id="2-Java的优势和特点"><a href="#2-Java的优势和特点" class="headerlink" title="2.Java的优势和特点"></a>2.Java的优势和特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">那我们看Java语言有什么优势和特点呢？<br>   *.做服务端系统性能高。<br>   *.有虚拟机，跨平台。<br>   *.功能强大，支持的类库多，生态圈类库多，开发框架和工具更易找。<br>   *.市场占有率高，约60%的中国程序员都是做Java相关的工作。<br></code></pre></td></tr></table></figure><h2 id="二-关于Go"><a href="#二-关于Go" class="headerlink" title="二.关于Go"></a>二.关于Go</h2><h3 id="1-Go的出生原因"><a href="#1-Go的出生原因" class="headerlink" title="1.Go的出生原因"></a>1.Go的出生原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go语言是Google内部公司大佬开发的，主要起因于Google公司有大量的C程序项目，但是开发起来效率太低，维护成本高，于是就开发了Go语言来提高效率，而且性能只是差一点。（Go是2007年开始研发，2009推出发布）<br></code></pre></td></tr></table></figure><h3 id="2-宏观看Go与Java的差异"><a href="#2-宏观看Go与Java的差异" class="headerlink" title="2.宏观看Go与Java的差异"></a>2.宏观看Go与Java的差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">接着，我们来看一下Go语言与Java的差异之处：<br>     *.无虚拟机，不跨平台(这里的平台指操作系统)(可以运行多个平台，每个平台打不同的二进制程序包)，需要打包编译成对应服务器操作系统版本(windows&#x2F;linux)的可执行程序(比如windows是exe)。(注:说go跨平台的是指32位和64位相同操作系统之间的跨平台)<br>•   *.因为Go程序直接打包成操作系统可执行的文件，没有虚拟机在中间转换的一层，所以理论上执行效率会更高（理论上更高，实际情况需具体分析)。<br>•   *.相比Java的语言和代码编写风格，Go更简洁，可以用更少的代码实现同样的功能。<br>•   *.Go语言底层也是C实现的，又做了高并发的设计(Java出生时(1995)还没有多核cpu,所以他的并发支持后来添加上去的,Go(2009)出生时已经有了多核cpu的电脑，它在设计语言时就考虑了充分利用多核cpu(英特尔2005首次推出多核)的性能)，所以性能高，高并发的支持(高并发支持其中指的一个就是充分利用多核cpu的性能资源，比如go程序默认使用所有cpu(除非自己设置使用多少))也好。<br>•   *.天然的适用一些特定系统的开发，比如区块链类系统(如以太坊底层系统、以太坊上层应用程序)，云计算和容器（Docker，K8s底层都是go开发的）开发的(大公司自研运维管理项目也大多是用go做底层的开发)，网络编程(类似于java的Netty)。<br></code></pre></td></tr></table></figure><h3 id="3-Go和Java的语言类型区别"><a href="#3-Go和Java的语言类型区别" class="headerlink" title="3.Go和Java的语言类型区别"></a>3.Go和Java的语言类型区别</h3><p>​        计算机编程语言按照运行的方式可以分为编译型编程语言和解释型编译语言。</p><p>​        我来举一个例子，你要教别人一门沟通交流的语言，比如英语。</p><p>​        编译型的教的方式就是录(这里的录相当于计算机中把程序编译成二进制可执行文件)一个视频课程，语音课程，把每一句英语发音录下来，这样学生学的时候只要播放你的录音，然后跟着读就行，你只需要录制一次，学生就可以无数次听。</p><p>​         解释性的教的方式就是你亲自到学生家里给他补习，你当面教他，你读(读相当于每次执行都重新用解释器解释一遍)一句他学一句，</p><p>这样的话，你想要教他一句你必须就得先读一句，每次教都得重新一遍一遍的读。</p><p>​          这两种教学方式还有一个差别，你录(编译)视频语音教他，你录的英语他就只能学英语，空间环境一变，他现在要去日本，要学日语，你的视频语音教程因为已经录好了，是英语类型(英语类型类比操作系统类型)的，所以，你就得再录一套日语的语音教程。</p><p>​         而现场教他，你也会日语的话，你只需要读(读相当于解释器解释)日语给他听，让他学就行了，是不用考虑语言环境(操作系统类型环境)不同的问题的。</p><p>​         现在我们再来看编程语言，我们的程序执行有两种方式，一种是编译成操作系统可执行的二进制可执行程序，这样相当于编译一次，之后每次执行都不用再编译了，但是因为不同操作系统对于二进制文件的执行规范不同，不同的操作系统你要编译成不同的可执行文件。</p><p>​         解释型语言就是多了一个解释器，解释器我们可以类比为一个老师，你执行一行代码我们类比为学一句话的读音，解释器解释一句，就是老师先读一句，你跟着才能读一句，也就是解释器每解释一行代码为可运行的代码，操作系统执行一行代码，这样的话每次执行都需要解释器重新解释一遍，执行几次就得解释几次。</p><p>​        Go是编译型的语言，运行在不同的平台需要打包成不同操作系统类型下的可执行文件。</p><p>​        Java是半编译，半解释型语言。编译是指他的代码都会编译成class类型的文件，class类型的文件只需要编译一次，可以在不同的操作系统的Java虚拟机上执行 ，半解释是指在Java虚拟机中，他还是需要一句一句的将class的二进制代码解释成对应操作系统可执行的代码。</p><h3 id="4-Go语言目前的主要应用场景"><a href="#4-Go语言目前的主要应用场景" class="headerlink" title="4.Go语言目前的主要应用场景"></a>4.Go语言目前的主要应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">*.和Java一样，Go语言最多的应用场景就是服务器后端系统的开发，包括Web后端，微服务后端接口。<br>*.Go非常适用需要高性能高并发的网络编程，这里的网络编程是指不需要界面，底层只是用Socket相互传输数据的系统，类似于Java中Netty的用途。<br>*.一些云计算容器，比如Docker，K8s，底层就是Go语言开发的，也可以用做底层自研运维项目的开发。<br>*.一些游戏系统的开发，可以用Go语言。<br>*.区块链的一些底层软件和一些应用软件。(区块链程序的第一开发语言)<br>    <br></code></pre></td></tr></table></figure><h2 id="三-Go和Java微观对比"><a href="#三-Go和Java微观对比" class="headerlink" title="三.Go和Java微观对比"></a>三.Go和Java微观对比</h2><h3 id="1-GoPath和Java的ClassPath"><a href="#1-GoPath和Java的ClassPath" class="headerlink" title="1.GoPath和Java的ClassPath"></a>1.GoPath和Java的ClassPath</h3><p>我们先来看看关于Java的classpath：</p><p>在我们的开发环境中，一个web程序(war包)有一个classpath,这个classpath在IDEA的开发工具中目录体现为src目录和resource目录，实际上在真正的war包中他定位的是指WEB-INF下的classes文件夹下的资源(比如class文件)。</p><p>我们编译后的文件都放在classpath(类路径)下。我们多个项目程序会有多个classpath目录。</p><p>在Go语言中，GoPath在同一系统上的同一用户，一般规定只有一个，无论这个用户创建多少个go项目，都只有一个GoPath,并且这些项目都放在GoPath下的src目录下。</p><p>GoPath下有三个目录：</p><p>​                        1.bin    （用于存放项目编译后的可执行文件）</p><p>​                        2.pkg     (用于存放类库文件，比如.a结尾的包模块)</p><p>​                        3.src    （用于存放项目代码源文件）    </p><p>注意：当我们在windows上开发Go程序时，需要新建一个文件夹(文件夹名任意)作为GOPATH的文件目录，在其中新建三个文件夹分别是：bin,pkg,src。如果是在集成开发工具上开发的话，需要在设置中把GOPATH路径设置为你自定义的那个文件夹，之后产生的文件和相关内容都会在其中。</p><p>如果是在linux上想跑测试开发执行go程序，需要在/etc/profile添加名为GOPATH的环境变量，目录设置好自己新建的。</p><p>例如：全局用户设置GOPATH环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">vi &#x2F;etc&#x2F;profile<br>#添加如下 目录可以灵活修改<br>export GOPATH&#x3D;&#x2F;pub&#x2F;go&#x2F;gopath<br>&#x2F;&#x2F;立即刷新环境变量生效<br>source &#x2F;etc&#x2F;profile<br></code></pre></td></tr></table></figure><p>单用户设置GOPATH环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">vi   ~&#x2F;.bash_profile<br><br>#添加如下 目录可以自己灵活修改<br>export GOPATH&#x3D;&#x2F;home&#x2F;user&#x2F;local&#x2F;soft&#x2F;go&#x2F;gopath<br>&#x2F;&#x2F;立即刷新环境变量生效<br>source vi   ~&#x2F;.bash_profile<br></code></pre></td></tr></table></figure><p>注意：这是在linux上开发go程序才需要的，如果只是生产运行程序的话是不需要任何东西的，直接运行二进制可执行程序包即可，他所有的依赖全部打进包中了。</p><p>如果是在windows下的cmd，dos窗口运行相关的go命令和程序，则需要在windows的【此电脑】–&gt;【右键】–&gt;【属性】–&gt;【高级系统设置】–&gt;【环境变量】-【新建一个系统变量】–&gt;【变量名为GOPATH，路径为你自己指定的自定义文件夹】（如果是在IDEA中开发，不需要在此配置环境变量，只需要在IDEA中配置好GOPATH的目录设置即可）</p><h3 id="2-Go的开发环境搭建"><a href="#2-Go的开发环境搭建" class="headerlink" title="2.Go的开发环境搭建"></a>2.Go的开发环境搭建</h3><p>（配置环境变量GOPATH参考上一节内容）</p><p>我们要开发Go的程序，需要如下两样东西：</p><p>   1.Go SDK</p><p>​    GO中文社区SDK下载地址：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a></p><p>​    go1.14(最新的)</p><p>​    我们用1.14版就可以，因为1.13后才完全支持Module功能。</p><p>​    有两种安装模式，一种是压缩包解压的方式，一种是图形化安装。    </p><p>​     推荐使用windows图形安装傻瓜式安装，windows图形安装下载这个</p><p>​     <a href="https://studygolang.com/dl/golang/go1.14.6.windows-amd64.msi">https://studygolang.com/dl/golang/go1.14.6.windows-amd64.msi</a></p><p>​     linux安装如下：</p><p>​        后续补上。。。</p><ol><li><p>Go的集成软件开发环境</p><p>​    参考三(4)中的go集成开发环境选择。</p></li></ol><h3 id="3-Go与Java的文件结构对比"><a href="#3-Go与Java的文件结构对比" class="headerlink" title="3.Go与Java的文件结构对比"></a>3.Go与Java的文件结构对比</h3><h4 id="1-go文件结构模板"><a href="#1-go文件结构模板" class="headerlink" title="1).go文件结构模板"></a>1).go文件结构模板</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//主程序必须是写成main包名</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//导入别的类库</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>    <br><br><span class="hljs-comment">//全局常量定义</span><br><span class="hljs-keyword">const</span>  num = <span class="hljs-number">10</span><br>  <br><span class="hljs-comment">//全局变量定义</span><br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;li_ming&quot;</span><br><br><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">type</span> P <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br>  <br><span class="hljs-comment">//初始化函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//main函数:程序入口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hello World!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Java文件结构"><a href="#2-Java文件结构" class="headerlink" title="2).Java文件结构"></a>2).Java文件结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//包名</span><br><span class="hljs-keyword">package</span> my_package;<br>       <br><span class="hljs-comment">//导入包中的类</span><br><span class="hljs-keyword">import</span> java.io.*；<br><br><span class="hljs-keyword">public</span> Class MainTest&#123; <br>    <span class="hljs-comment">//main方法:程序入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">static</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br>    &#125;<br>&#125;<br><span class="hljs-comment">//people类</span><br>Class People &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>            <br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>                <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Go与Java的集成开发环境"><a href="#4-Go与Java的集成开发环境" class="headerlink" title="4.Go与Java的集成开发环境"></a>4.Go与Java的集成开发环境</h3><h4 id="1-Go的集成开发环境"><a href="#1-Go的集成开发环境" class="headerlink" title="1).Go的集成开发环境"></a>1).Go的集成开发环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">最常用的有三种：<br>Visual Studio Code(VS Code) 微软开发的一款Go语言开发工具。<br>LiteIDE 是国人开发的Go语言开发工具。<br>GoLand 这个非常好用，和Java中的IDEA是一家公司。(推荐使用)<br></code></pre></td></tr></table></figure><h4 id="2-Java的集成开发环境"><a href="#2-Java的集成开发环境" class="headerlink" title="2).Java的集成开发环境"></a>2).Java的集成开发环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">MyEclipse,Eclipse(已过时)。<br>IntelliJ IDEA(大多数用这个)。<br></code></pre></td></tr></table></figure><h3 id="5-Go和Java常用包的对比"><a href="#5-Go和Java常用包的对比" class="headerlink" title="5.Go和Java常用包的对比"></a>5.Go和Java常用包的对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go中文API文档地址：<br>https:&#x2F;&#x2F;studygolang.com&#x2F;pkgdoc<br>                Go                                              Java         <br><br>IO流操作：      bufio&#x2F;os                                     java.lang.io<br>字符串操作：      strings                                    java.lang.String<br>容器           container(heap&#x2F;list&#x2F;ring)                    java.lang.Collection<br>锁               sync                                       juc<br>时间              time                                      java.time&#x2F;java.lang.Date<br>算数操作          math                                       java.math<br>底层Unsafe       unsafe                                     unsafe类       <br></code></pre></td></tr></table></figure><h3 id="6-Go的常用基础数据类型和Java的基础数据类型对比"><a href="#6-Go的常用基础数据类型和Java的基础数据类型对比" class="headerlink" title="6.Go的常用基础数据类型和Java的基础数据类型对比"></a>6.Go的常用基础数据类型和Java的基础数据类型对比</h3><h4 id="1-go中的常用基础数据类型有："><a href="#1-go中的常用基础数据类型有：" class="headerlink" title="1).go中的常用基础数据类型有："></a>1).go中的常用基础数据类型有：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">1.布尔型：关键字【bool】： true   false<br>2.有符号整形：头一位是代表正负<br>            int   默认整形   4或8字节                32位或64位     <br>            int8             1字节                     8位<br>            int16            2字节                     16位<br>            int32            4字节                     32位<br>            in64             8字节                     64位<br>            【int是32还是64位取决于操作系统的位数，现在电脑一般都是64位的了，所以一般都是64位】<br>3.无符号整形<br>            uint             4或8字节               32位或64位<br>            uint8             1字节                     8位<br>            uint16            2字节                     16位<br>            uint32            4字节                     32位<br>            uint64            8字节                     64位<br>4.浮点型<br>            注：go语言没有float类型，只有float32和float64。<br>            float32           32位浮点数  <br>            float64           64位浮点数<br>5.字符串<br>            string<br>6. byte     等同uint8，只是类似于一个别名的东西<br>   rune     等同int32  只是一个别名，强调表示编码概念对应的数字<br></code></pre></td></tr></table></figure><h4 id="2-go中派生数据类型有："><a href="#2-go中派生数据类型有：" class="headerlink" title="2).go中派生数据类型有："></a>2).go中派生数据类型有：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">注:这里简单列举一下<br>指针      Pointer<br>数组      Array[]<br>结构体     struct<br>进程管道： channel <br>函数       func<br>切片      slice<br>接口      interface<br>哈希       map<br></code></pre></td></tr></table></figure><h4 id="3-Java中的基础数据类型"><a href="#3-Java中的基础数据类型" class="headerlink" title="3).Java中的基础数据类型"></a>3).Java中的基础数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br></code></pre></td></tr></table></figure><h3 id="7-Go和Java的变量对比"><a href="#7-Go和Java的变量对比" class="headerlink" title="7.Go和Java的变量对比"></a>7.Go和Java的变量对比</h3><h4 id="1-go的变量"><a href="#1-go的变量" class="headerlink" title="1).go的变量"></a>1).go的变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>   <span class="hljs-comment">//包含print函数</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//var  变量名  变量类型 = 变量值</span><br>   <span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;li_ming&quot;</span><br>   <span class="hljs-comment">//方法内部可以直接使用 【 变量名 := 变量值 】 赋值，方法外不可以</span><br>   name2:=<span class="hljs-string">&quot;xiao_hong&quot;</span><br>   fmt.Println(<span class="hljs-string">&quot;name = &quot;</span>,name)<br>   fmt.Println(<span class="hljs-string">&quot;name2 = &quot;</span>,name2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Java的变量"><a href="#2-Java的变量" class="headerlink" title="2).Java的变量"></a>2).Java的变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//变量类型  变量名 = 变量值</span><br>        String name = <span class="hljs-string">&quot;li_ming&quot;</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;name =&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;i =&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-Go和Java的常量对比"><a href="#8-Go和Java的常量对比" class="headerlink" title="8.Go和Java的常量对比"></a>8.Go和Java的常量对比</h3><h4 id="1-go的常量"><a href="#1-go的常量" class="headerlink" title="1).go的常量"></a>1).go的常量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>中的常量和java中的常量含义有一个本质的区别：<br><span class="hljs-keyword">go</span>中的常量是指在编译期间就能确定的量(数据)，<br>而java中的常量是指被赋值一次后就不能修改的量(数据)。<br>所以两者不一样，因为Java中的常量也是JVM跑起来后赋值的，只不过不允许更改；<br><span class="hljs-keyword">go</span>的常量在编译后就确实是什么数值了。<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>   <span class="hljs-comment">//包含print函数</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//const  常量名  常量类型 = 常量值   显示推断类型</span><br>   <span class="hljs-keyword">const</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;const_li_ming&quot;</span><br>   <span class="hljs-comment">//隐式推断类型</span><br>   <span class="hljs-keyword">const</span> name2 =<span class="hljs-string">&quot;const_xiao_hong&quot;</span><br>   fmt.Println(<span class="hljs-string">&quot;name = &quot;</span>,name)<br>   fmt.Println(<span class="hljs-string">&quot;name2 = &quot;</span>,name2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Java的常量"><a href="#2-Java的常量" class="headerlink" title="2).Java的常量"></a>2).Java的常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>    <span class="hljs-comment">//【访问修饰符】 【静态修饰符】final修饰符   常量类型   常量名 =  常量值；</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;A&quot;</span>;    <span class="hljs-comment">//一般设置为static静态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;tag= &quot;</span>+TAG);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-Go与Java的赋值对比"><a href="#9-Go与Java的赋值对比" class="headerlink" title="9.Go与Java的赋值对比"></a>9.Go与Java的赋值对比</h3><h4 id="1-go的赋值"><a href="#1-go的赋值" class="headerlink" title="1).go的赋值"></a>1).go的赋值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go">Go方法内的赋值符号可以用  := ,也可以用 =,方法外只能用 = 。<br>例如:<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>   <span class="hljs-comment">//包含print函数</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">//方法外只能用 = 赋值</span><br><span class="hljs-keyword">var</span> my_name  <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;my_name&quot;</span><br><span class="hljs-keyword">var</span> my_name2 = <span class="hljs-string">&quot;my_name2&quot;</span><br><span class="hljs-comment">//my_name3:=&quot;my_name3&quot;    不在方法内，错误</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;name = &quot;</span>,my_name)<br>   fmt.Println(<span class="hljs-string">&quot;name2 = &quot;</span>,my_name2)<br>&#125;<br>Go支持多变量同时赋值：<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>   <span class="hljs-comment">//包含print函数</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//多变量同时赋值</span><br>   <span class="hljs-keyword">var</span> name,name2 = <span class="hljs-string">&quot;li_ming&quot;</span>,<span class="hljs-string">&quot;xiao_hong&quot;</span><br>   fmt.Println(<span class="hljs-string">&quot;name = &quot;</span>,name)<br>   fmt.Println(<span class="hljs-string">&quot;name2 = &quot;</span>,name2)<br>&#125;<br>Go的丢弃赋值<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>   <span class="hljs-comment">//包含print函数</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//丢弃赋值    把 1和2丢弃 只取3</span><br>   <span class="hljs-comment">//在必须一次取两个以上的值的场景下，又不想要其中一个值的时候使用，比如从map中取key,value</span><br>   <span class="hljs-keyword">var</span> _,_,num = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>   fmt.Println(<span class="hljs-string">&quot;num = &quot;</span>,num)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-java的赋值"><a href="#2-java的赋值" class="headerlink" title="2).java的赋值"></a>2).java的赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//直接用 = 赋值</span><br>        String name = <span class="hljs-string">&quot;li_ming&quot;</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;name =&quot;</span>+name);<br>        System.out.println(<span class="hljs-string">&quot;i =&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-Go与Java的注释"><a href="#10-Go与Java的注释" class="headerlink" title="10.Go与Java的注释"></a>10.Go与Java的注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go中的注释写法和Java中的基本一样。<br>例如：<br>&#x2F;&#x2F;单行注释,两者相同<br>&#x2F;*<br>    Go的多行注释<br>*&#x2F;<br>&#x2F;**<br>    Java多行注释<br>*&#x2F;<br></code></pre></td></tr></table></figure><h3 id="11-Go和Java的访问权限设置区别"><a href="#11-Go和Java的访问权限设置区别" class="headerlink" title="11.Go和Java的访问权限设置区别"></a>11.Go和Java的访问权限设置区别</h3><p>首先我们来回忆一下，Java的权限访问修饰符有哪些？</p><p>public      全局可见</p><p>protected  继承相关的类可见</p><p>default   同包可见</p><p>private    私有的，本类可见</p><p>关于Java中的访问权限修饰符，是用于修饰变量，方法，类的，被修饰的对象被不同的访问权限修饰符修饰后，其它程序代码要想访问它，必须在规定的访问范围内才可以，比如同包，同类，父子类，全局均可访问。</p><p>那么，Go中的访问权限设置又有什么区别呢？</p><p>要理解这个问题，首先我们要来看一下一个Go程序的程序文件组织结构是什么样子的？</p><p>一个可运行的编译后的Go程序，必须有一个入口，程序从入口开始执行，这个入口必须是main包，并且从main包的main函数开始执行。</p><p>但是，为了开发的效率和管理开发任务的协调简单化，对于代码质量的可复用，可扩展等特性的要求，我们一般采用面向对象的，文件分模块式的开发。</p><p>比如，我是一个游戏程序，我的main函数启动后，首先要启动UI界面，那么关于UI界面相关的代码我们一般会专门分出一个模块去开发，然后这个模块有很多个程序文件，这里关于UI模块比如有3个文件，a.go,b.go,c.go，那么我们在实际当中会建一个以ui为名的包文件夹，然后把a.go,b.go,c.go全部放到ui这个包文件夹下，然后因为这个包没有main包，没有main函数，所以它打出来的一个程序文件就是以.a结尾的工具包，类似于Java中的jar包，工具包文件名为  ui.a。</p><p>参考如下：</p><p>—-com.mashibing.mygame.ui</p><p>​        ————————————a.go</p><p>​        ————————————b.go</p><p>​        ————————————c.go</p><p>a.go文件如下示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//这里的ui，也就是package后面的名称尽量和包文件夹的名称一致，不一致也可以</span><br><span class="hljs-keyword">package</span> ui<br><br><span class="hljs-comment">//相关方法和业务</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <br>&#125;<br><span class="hljs-comment">//启动游戏UI</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartGameUI</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意一个点，在程序中的 package后面的 ui包名可以和文件夹com.mashibing.mygame.ui中最后一层的ui文件夹名称不一致，</p><p>我们一般按规范写是要求写一致的，不一致时的区别如下：</p><p>我们把ui.a打包完毕后，我们就可以在别的程序中用import导入这个包模块 ，然后使用其中的内容了。</p><p>上面两个ui不同之处在于，在我们import 的代码后面，需要写的模块名称是在 ${gopath}/src/下的文件夹名，也就是com.mashibing.mygame.ui中的ui。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//游戏主程序</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//这里的ui是com.mashibing.mygame.ui的最后一层文件夹名</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;ui&quot;</span><br><br><span class="hljs-comment">//相关方法和业务</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//这里的ui不是文件夹名，而是之前a.go程序中package后面写的包名</span><br>    ui.StartGameUI()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="file://C:/Users/QianMo/Desktop/golang4javaer/001fmt.png?lastModify=1617429469" alt="image-20200714105542267"></p><p><img src="file://C:/Users/QianMo/Desktop/golang4javaer/002fmt.png?lastModify=1617429469" alt="image-20200714105755853"></p><p>接下来进入主题，我们的go语言关于访问修饰符的是指的限制什么权限，以及如何实现？</p><p>我们之前可以看出来，实战中的go程序是有一个main程序import很多其它包模块，每个模块实现对应的功能，最后统一在main程序中组合来完成整个软件程序，那么有一些其它模块的函数和变量，我只想在本程序文件中调用，不想被其它程序import能调用到，如何实现？</p><p>import后是否能调用对应包中的对象(变量，结构体，函数之类的)就是go关于访问权限的定义，import后，可以访问，说明是开启了访问权限，不可以访问，是说明关闭了其它程序访问的权限。</p><p>在go中，为了遵循实现简洁，快速的原则，用默认的规范来规定访问权限设置。</p><p>默认规范是：某种类型（包括变量，结构体，函数，类型等）的名称定义首字母大写就是在其它包可以访问，首字母非大写，就是只能在自己的程序中访问。</p><p>这样我们就能理解为什么导入fmt包后，他的PrintF函数的首字母P是大写的。</p><p>参照如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ui<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//这里的P是大写</span><br>   <span class="hljs-comment">//所有调用别的包下的函数，都是首字母大写</span><br>   fmt.Printf(<span class="hljs-string">&quot;aa&quot;</span>)<br>&#125;<br><span class="hljs-comment">//这里的Person的首字母P也是表示外部程序导入该包后可以使用此Person类</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;<br><br>&#125;<br><span class="hljs-comment">//这里的D同上</span><br><span class="hljs-keyword">var</span> Data <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;li_ming&quot;</span><br></code></pre></td></tr></table></figure><h3 id="12-Go与Java程序文件的后缀名对比"><a href="#12-Go与Java程序文件的后缀名对比" class="headerlink" title="12.Go与Java程序文件的后缀名对比"></a>12.Go与Java程序文件的后缀名对比</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">Java的编译文件是.class结尾,多个.class打成的一个可执行文件是.jar结尾,.jar不能直接在windows和linux上执行,得用java命令在JVM中执行。<br><br>Go语言的程序文件后缀为.go,有main包main函数的,.go文件打包成二进制对应操作系统的可执行程序,如windows上的.exe结尾的可执行程序。<br><br>Java的类库会以.jar结尾，Go语言非main包没有main函数的程序编译打包会打成一个类库，以.a结尾,也就是说Go语言的类库以.a结尾。<br><br>Go的类库如下:<br>            包名.a     <br>            my_util.a<br>注：my_util是最顶层文件夹名，里面包含着一个个程序文件。<br></code></pre></td></tr></table></figure><h3 id="13-Go与Java选择结构的对比"><a href="#13-Go与Java选择结构的对比" class="headerlink" title="13.Go与Java选择结构的对比"></a>13.Go与Java选择结构的对比</h3><h4 id="1-if"><a href="#1-if" class="headerlink" title="1).if"></a>1).if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go中的if和Java中的if使用相同，只不过是把小括号给去掉了。       <br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      单分支结构语法格式如下:</span><br><span class="hljs-comment">         if 条件判断 &#123;</span><br><span class="hljs-comment">            //代码块</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;请输入数字&quot;</span>)<br>   fmt.Scan(&amp;num)<br><br>   <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字大于10&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      if else分支结构语法格式如下:</span><br><span class="hljs-comment">         if 条件判断 &#123;</span><br><span class="hljs-comment">            //代码块</span><br><span class="hljs-comment">         &#125; else &#123;</span><br><span class="hljs-comment">            //代码快2</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;请输入数字&quot;</span>)<br>   fmt.Scan(&amp;num)<br><br>   <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字大于10&quot;</span>)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字不大于10&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      if else分支结构语法格式如下:</span><br><span class="hljs-comment">         if 条件判断 &#123;</span><br><span class="hljs-comment">            //代码块</span><br><span class="hljs-comment">         &#125; else if 条件判断&#123;</span><br><span class="hljs-comment">            //代码块2</span><br><span class="hljs-comment">         &#125; else &#123;</span><br><span class="hljs-comment">            //代码块3</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><br><br>   fmt.Printf(<span class="hljs-string">&quot;请输入数字&quot;</span>)<br>   fmt.Scan(&amp;num)<br><br>   <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">10</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字大于10&quot;</span>)<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num == <span class="hljs-number">10</span>&#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字等于10&quot;</span>)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;您输入的数字小于10&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-switch"><a href="#2-switch" class="headerlink" title="2).switch"></a>2).switch</h4><p>示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;li_ming&quot;</span><br>   <span class="hljs-keyword">switch</span> a &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;li_ming&quot;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;Hello!LiMing&quot;</span>)<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;xiao_hong&quot;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;Hello!XiaoHong&quot;</span>)<br>   <span class="hljs-keyword">default</span>:<br>      fmt.Println(<span class="hljs-string">&quot;No!&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：一分支多值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>   <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;li_ming&quot;</span><br>   <span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&quot;xiao_hong&quot;</span><br>   <span class="hljs-keyword">switch</span> name &#123;<br>   <span class="hljs-comment">//li_ming或xiao_hong 均进入此</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;li_ming&quot;</span>, <span class="hljs-string">&quot;xiao_hong&quot;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;li_ming and xiao_hong&quot;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">switch</span> name2 &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;li_ming&quot;</span>, <span class="hljs-string">&quot;xiao_hong&quot;</span>:<br>      fmt.Println(<span class="hljs-string">&quot;li_ming and xiao_hong&quot;</span>)<br>   &#125;<br>&#125;g<br></code></pre></td></tr></table></figure><p>示例3：switch表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">11</span><br>   <span class="hljs-keyword">switch</span>&#123;<br>      <span class="hljs-keyword">case</span> num &gt; <span class="hljs-number">10</span> &amp;&amp; num &lt; <span class="hljs-number">20</span>:<br>         fmt.Println(num)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例4：fallthrough下面的case全部执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> num = <span class="hljs-number">11</span><br>   <span class="hljs-keyword">switch</span> &#123;<br>   <span class="hljs-keyword">case</span> num == <span class="hljs-number">11</span>:<br>      fmt.Println(<span class="hljs-string">&quot;==11&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">10</span>:<br>      fmt.Println(<span class="hljs-string">&quot;&lt;12&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-Go与Java循环结构的对比"><a href="#14-Go与Java循环结构的对比" class="headerlink" title="14.Go与Java循环结构的对比"></a>14.Go与Java循环结构的对比</h3><h4 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1).for循环"></a>1).for循环</h4><p>示例1：省略小括号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      fmt.Println(i)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：和while相同，break,continue同java</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-comment">//省略另外两项，相当于java中的while</span><br>   <span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">3</span> &#123;<br>      i++<br>   &#125;<br>   <span class="hljs-comment">//break用法相同</span><br>   <span class="hljs-keyword">for</span> i == <span class="hljs-number">3</span> &#123;<br>      fmt.Println(i)<br>      <span class="hljs-keyword">break</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例3：死循环，三项均省略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br><br>   &#125;<br><br>   <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span> &#123;<br><br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>示例4：嵌套循环和java也一样，不演示了</p><p>示例5： range循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> data [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;<br>   <span class="hljs-keyword">for</span>  i, num := <span class="hljs-keyword">range</span> data &#123;<br>      fmt.Println(i,num)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-goto"><a href="#2-goto" class="headerlink" title="2).goto"></a>2).goto</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//goto可以用在任何地方，但是不能跨函数使用</span><br>   fmt.Println(<span class="hljs-string">&quot;start&quot;</span>)<br><br>   <span class="hljs-comment">//go to的作用是跳转，中间的语句不执行，无条件跳转</span><br>   <span class="hljs-keyword">goto</span> my_location <span class="hljs-comment">//goto是关键字， my_location可以自定义，他叫标签</span><br><br>   fmt.Println(<span class="hljs-string">&quot;over&quot;</span>)<br>   my_location:<br>   fmt.Println(<span class="hljs-string">&quot;location&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="15-Go与Java的数组对比"><a href="#15-Go与Java的数组对比" class="headerlink" title="15.Go与Java的数组对比"></a>15.Go与Java的数组对比</h3><p>1）go的一维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">var 数组名 [数组长度]数组类型  &#x3D; [数组长度]数组类型&#123;元素1，元素2...&#125;<br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">//全局</span><br><span class="hljs-keyword">var</span> my_arr [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> my_arr_1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//方法内：</span><br>   this_arr := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>   fmt.Println(my_arr)<br>   fmt.Println(my_arr_1)<br>   fmt.Println(this_arr)<br>&#125;<br></code></pre></td></tr></table></figure><p>2）二维数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">//全局</span><br><span class="hljs-keyword">var</span> my_arr [<span class="hljs-number">4</span>][<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> my_arr_1 [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [...][<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//方法内：</span><br>   this_arr := [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;&#125;<br>   <span class="hljs-comment">// 第 2 纬度不能用 &quot;...&quot;。</span><br>   this_arr2 := [...][<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;&#125;<br>   fmt.Println(my_arr)<br>   fmt.Println(my_arr_1)<br>   fmt.Println(this_arr)<br>   fmt.Println(this_arr2)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="16-Go有指针概念，Java没有指针概念"><a href="#16-Go有指针概念，Java没有指针概念" class="headerlink" title="16.Go有指针概念，Java没有指针概念"></a>16.Go有指针概念，Java没有指针概念</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">Go中有指针的概念，Java中没有指针的概念。<br>指针简单的说就是存储一个【变量地址】的【变量】。<br>Go中使用指针的方法<br><span class="hljs-comment">//*+变量类型 = 对应变量类型的指针类型，&amp;+变量名 = 获取变量引用地址    </span><br><span class="hljs-keyword">var</span>  指针变量名 *指针变量类型 = &amp;变量名  <br>例如：<br><span class="hljs-keyword">var</span> my_point *<span class="hljs-keyword">int</span> = &amp;num<br><span class="hljs-comment">//通过&amp;+指针变量 = 修改原来的变量真实值</span><br>&amp;指针变量名 = 修改的变量值<br>例如：<br>&amp;my_point = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 声明实际变量</span><br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span>=<span class="hljs-string">&quot;li_ming&quot;</span><br><span class="hljs-comment">// 声明指针变量</span><br><span class="hljs-keyword">var</span> name_point *<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 指针变量的存储地址</span><br>name_point = &amp;name<br><span class="hljs-comment">//直接访问变量地址</span><br>fmt.Println(<span class="hljs-string">&quot;name 变量的地址是:&quot;</span>, &amp;name  )<br><span class="hljs-comment">// 指针变量的存储地址</span><br>fmt.Println(<span class="hljs-string">&quot;name_point变量储存的指针地址:&quot;</span>, name_point )<br><span class="hljs-comment">// 使用指针访问值</span><br>fmt.Println(<span class="hljs-string">&quot;*name_point 变量的值:&quot;</span>, *name_point )<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">name 变量的地址是: 0x10ae40f0<br>name_point变量储存的指针地址: 0x10ae40f0<br>*name_point 变量的值: li_ming<br></code></pre></td></tr></table></figure><h3 id="17-Go语言的中new-make和Java中的new对象有什么区别？"><a href="#17-Go语言的中new-make和Java中的new对象有什么区别？" class="headerlink" title="17.Go语言的中new,make和Java中的new对象有什么区别？"></a>17.Go语言的中new,make和Java中的new对象有什么区别？</h3><p> 首先，Java中的new关键字代表创建关于某一个类的一个新的对象。</p><p> 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">List list &#x3D; new ArrayList(); <br></code></pre></td></tr></table></figure><p>  Go中的创建一个struct结构体的对象，是不需要用new关键字的，参考【20】中有代码示例讲解如何创建结构体对象。</p><p>  Go中new的概念是和内存相关的，我们可以通过new来为基础数据类型申请一块内存地址空间，然后把这个把这个内存地址空间赋值给</p><p>  一个指针变量上。（new主要就是为基础数据类型申请内存空间的，当我们需要一个基础数据类型的指针变量，并且在初始化这个基础指针变量时，不能确定他的初始值，此时我们才需要用new去内存中申请一块空间，并把这空间绑定到对应的指针上，之后可以用该指针为这块内存空间写值。new关键字在实际开发中很少使用，和java很多处用new的情况大不相同）</p><p> 参考如下示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> num *<span class="hljs-keyword">int</span><br>   <span class="hljs-comment">//此处num是nil</span><br>   fmt.Println(num)<br>   <span class="hljs-comment">//此处会报空指针异常，因为num为nil,没有申请内存空间，所以不能为nil赋值</span><br>   *num = <span class="hljs-number">1</span><br>   fmt.Println(*num)<br>&#125;<br></code></pre></td></tr></table></figure><p>改为如下代码即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//在内存中申请一块地址，并把内存地址存入num</span><br>   <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>   <span class="hljs-comment">//此处num的值是申请出来的内存空间地址值，一个十六进制的数字</span><br>   fmt.Println(num)<br>   <span class="hljs-comment">//正常</span><br>   *num = <span class="hljs-number">1</span><br>   fmt.Println(*num)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们来看一个go中的make是做什么用的？</p><p>go中的make是用来创建slice(切片)，map(映射表)，chan(线程通信管道)这三个类型的对象的，返回的就是对应类型的对象，他的作用就相当于Java中new一个ArrayList，new一个HashMap时候的new的作用，只不过是go语法规定用make来创建slice(切片)，map(映射表)，chan(线程通信管道)。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//make只能为map,channel,slice申请分配内存，只有这三种，没有第四种</span><br>   <span class="hljs-comment">//所有通过make创建的这三种类型都是引用类型，传递参数时虽然是引用值传递，</span><br>   <span class="hljs-comment">//但是对方法内引用变量参数的修改可以影响到外部的引用变量</span><br>   <span class="hljs-comment">//1.通过make创建map对象  如下代码类似于Java中 Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span><br>   <span class="hljs-comment">//在这里make就是申请分配map的内存，和java中创建map的new一样</span><br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>   myMap[<span class="hljs-string">&quot;li_ming&quot;</span>] = <span class="hljs-number">20</span><br><br>   <span class="hljs-comment">//2.通过make创建channel,make函数内可以有一个参数，也可以有两个参数，有两个参数时第二个参数</span><br>   <span class="hljs-comment">//为通道的缓存队列的长度</span><br>   <span class="hljs-comment">//2.1) 只有一个参数，通道的缓存队列长度此时为0，也就是无缓存。</span><br>   <span class="hljs-comment">//创建一个传输int类型数据的通道</span><br>   myChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>   fmt.Println(myChan)<br>   <span class="hljs-comment">//2.2) 有两个参数，第二个参数2代表此时代表缓存队列的长度为2</span><br>   <span class="hljs-comment">//创建一个传输int类型数据的通道,缓存为2</span><br>   mychan2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">2</span>)<br>   fmt.Println(mychan2)<br>   <span class="hljs-comment">//此处暂时不做通道缓存队列数多少有何区别的讲解</span><br><br>   <span class="hljs-comment">//3.通过make创建slice切片</span><br>   <span class="hljs-comment">//有两种方式，一种是两个参数，一种是三个参数</span><br>   <span class="hljs-comment">//我们只有在创建一个空的切片时才会使用make</span><br>   <span class="hljs-comment">//如果通过一个已有的数组创建切片往往是下面的形式</span><br>   <span class="hljs-comment">//创建一个底层数组</span><br>   myArr := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>   <span class="hljs-comment">//如果通过一个数组创建切片，往往是用 原始数组变量名[切片起始位置:切片结束位置] 创建一个切片</span><br>   mySlice1 := myArr[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br>   fmt.Println(mySlice1)<br>   <span class="hljs-comment">//我们如果是想创建一个空的slice,则用make创建切片</span><br>   <span class="hljs-comment">//如下形式 make(int[],num1,num2)</span><br>   <span class="hljs-comment">//num1 = 切片的长度(默认分配内存空间的元素个数)</span><br>   <span class="hljs-comment">//num2 = 切片的容量(解释：底层数组的长度/切片的容量，超过底层数组长度append新元素时会创建一个新的底层数组，</span><br>   <span class="hljs-comment">//不超过则会使用原来的底层数组)</span><br><br>   <span class="hljs-comment">//代表底层数组的长度是4,默认给底层数组的前两个元素分配内存空间</span><br>   <span class="hljs-comment">//切片指向前两个元素的地址，如果append新元素，在元素数小于4时都会</span><br>   <span class="hljs-comment">//在原来的底层数组的最后一个元素新分配空间和赋值，</span><br>   <span class="hljs-comment">//append超过4个元素时，因为原数组大小不可变，也也存储不下了，</span><br>   <span class="hljs-comment">//所以会新创建一个新的底层数组，切片指向新的底层数组</span><br>   mySliceEmpty := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>   fmt.Println(mySliceEmpty)<br><br>   <span class="hljs-comment">//两个参数，代表切片的长度和切片的容量(底层数组长度)均为第二个参数那个值</span><br>   mySliceEmpty2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>)<br>   fmt.Println(mySliceEmpty2)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-Go相关的数据容器和Java的集合框架对比"><a href="#18-Go相关的数据容器和Java的集合框架对比" class="headerlink" title="18.Go相关的数据容器和Java的集合框架对比"></a>18.Go相关的数据容器和Java的集合框架对比</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go中有的数据结构：数组，切片，map，双向链表，环形链表，堆<br>Go自己的类库中没有set,没有集合(List)，但是第三方库有实现。<br>Java中有： Map,Set,List,Queue,Stack,数组<br>Java中没有切片的概念。<br>Go中的数组打印格式是[1,2,3,4,5] <br>Go中的切片打印格式是[[1,2,3]]<br>Go中切片的概念：切片是数组的一个子集，就是数组截取某一段。<br>Go的map和Java的map大致相同<br></code></pre></td></tr></table></figure><h3 id="19-Go中的函数，Go的方法和Java中的方法对比"><a href="#19-Go中的函数，Go的方法和Java中的方法对比" class="headerlink" title="19.Go中的函数，Go的方法和Java中的方法对比"></a>19.Go中的函数，Go的方法和Java中的方法对比</h3><h4 id="1-Go中的函数定义"><a href="#1-Go中的函数定义" class="headerlink" title="1).Go中的函数定义"></a>1).Go中的函数定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">Go中返回值可以有多个，不像Java中多个值得封装到实体或map返回<br>&#x2F;&#x2F;注：【】内的返回值可不写，无返回值直接把返回值部分全部去掉即可。<br>func 函数名(变量1 变量类型，变量2 变量2类型...)【(返回值1 类型1，返回值2 类型2...)】  &#123;        &#x2F;&#x2F;注意：这个方法的右中括号必须和func写在同一行才行，否则报错，不能按c语言中的换行写<br></code></pre></td></tr></table></figure><p> 示例1：        </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//定义局部变量</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">200</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-keyword">int</span><br><br>   <span class="hljs-comment">//调用函数并返回最大值</span><br>   result = max(a, b)<br><br>   fmt.Println( <span class="hljs-string">&quot;最大值是 :&quot;</span>, result )<br>&#125;<br><br><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-keyword">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>  示例2：返回多个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;li_ming&quot;</span>, <span class="hljs-string">&quot;xiao_hong&quot;</span>)<br>   fmt.Println(a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-comment">//返回多个值</span><br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：函数的参数：基础类型是按值传递，复杂类型是按引用传递</p><p>示例3： 函数的参数：变长参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>manyArgs(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>manyArgs(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>)<br>dataStr := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;11&quot;</span>&#125;<br><span class="hljs-comment">//传数组也可以，加三个点</span><br>manyArgs(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,dataStr...)<br>&#125;<br><br><span class="hljs-comment">//可变参数必须放在最后面</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">manyArgs</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>,b <span class="hljs-keyword">int</span> ,str ...<span class="hljs-keyword">string</span> )</span></span>&#123;<br><span class="hljs-keyword">for</span> i,s := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Println(i,s)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：函数的返回值：如果有返回值，返回值的类型必须写，返回值得变量名根据情况可写可不写。</p><p>示例4： defer：推迟执行(类似于java中的finally)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   testMyFunc();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer1</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;print defer1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer2</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;print defer2&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testMyFunc</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//defer会在方法返回前执行，有点像java中的finally</span><br>   <span class="hljs-comment">//defer写在任意位置均可，多个defer的话按照逆序依次执行</span><br>   <span class="hljs-keyword">defer</span> testDefer2()<br>   <span class="hljs-keyword">defer</span> testDefer1()<br>   fmt.Println(<span class="hljs-string">&quot;print my func&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>示例5 ：丢弃返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//方式一丢弃：丢弃num1和str</span><br>   _,num2,_:= testFun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>   fmt.Println(num2)<br>   <span class="hljs-comment">//方式二丢弃：</span><br>   _,num3,_:= testFun(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;4&quot;</span>);<br>   fmt.Println(num3)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testFun</span><span class="hljs-params">(num1,num2 <span class="hljs-keyword">int</span>,str <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(n1 <span class="hljs-keyword">int</span>,n2 <span class="hljs-keyword">int</span>,s1 <span class="hljs-keyword">string</span>)</span></span>&#123;<br>   n1 = num1<br>   n2 = num2<br>   s1 = str<br>   <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testFun2</span><span class="hljs-params">(num1,num2 <span class="hljs-keyword">int</span>,str <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">string</span>)</span></span>&#123;<br>   <span class="hljs-keyword">return</span> num1,num2,str<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Java中的方法定义"><a href="#2-Java中的方法定义" class="headerlink" title="2).Java中的方法定义"></a>2).Java中的方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">访问修饰符   返回值类型   方法名(参数1类型  参数1，参数2类型 参数2...) &#123;<br><br>      return 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><p>  示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Integer doSomething(String name,Integer age) &#123;<br>   <br>return 20;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20-Go的内置函数和Java的默认导入包java-lang"><a href="#20-Go的内置函数和Java的默认导入包java-lang" class="headerlink" title="20.Go的内置函数和Java的默认导入包java.lang.*"></a>20.Go的内置函数和Java的默认导入包java.lang.*</h3><p>为了在Java中快速开发，Java语言的创造者把一些常用的类和接口都放到到java.lang包下，lang包下的特点就是不用写import语句导入包就可以用里面的程序代码。</p><p>Go中也有类似的功能，叫做Go的内置函数，Go的内置函数是指不用导入任何包，直接就可以通过函数名进行调用的函数。</p><p>Go中的内置函数有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">close          关闭channel<br><br>len            求长度<br><br>make      创建slice,map,chan对象<br><br>append      追加元素到切片(slice)中<br> <br>panic         抛出异常，终止程序<br><br>recover       尝试恢复异常，必须写在defer相关的代码块中<br></code></pre></td></tr></table></figure><p>参考示例代码1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   array := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>   str := <span class="hljs-string">&quot;myName&quot;</span><br>   <span class="hljs-comment">//获取字符串长度</span><br>   fmt.Println(<span class="hljs-built_in">len</span>(str))<br>   <span class="hljs-comment">//获取数组长度</span><br>   fmt.Println(<span class="hljs-built_in">len</span>(array))<br>   <span class="hljs-comment">//获取切片长度</span><br>   fmt.Println(<span class="hljs-built_in">len</span>(array[<span class="hljs-number">1</span>:]))<br><br>   <span class="hljs-comment">//make创建channel示例</span><br>   intChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">1</span>)<br>   <span class="hljs-comment">//make创建map示例</span><br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>   <span class="hljs-comment">//make创建切片</span><br>   mySlice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br><br>   fmt.Println(intChan)<br>   fmt.Println(myMap)<br>   fmt.Println(mySlice)<br><br>   <span class="hljs-comment">//关闭管道</span><br>   <span class="hljs-built_in">close</span>(intChan)<br>   <span class="hljs-comment">//为切片添加元素</span><br>   array2 := <span class="hljs-built_in">append</span>(array[:],<span class="hljs-number">6</span>)<br>   <span class="hljs-comment">//输出</span><br>   fmt.Println(array2)<br><br>   <span class="hljs-comment">//new案例</span><br>   num := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>   fmt.Println(num)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>参考示例代码2：panic和recover的使用</p><p>他们用于抛出异常和尝试捕获恢复异常</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 刚刚打开某资源</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br>fmt.Println(err)<br>fmt.Println(<span class="hljs-string">&quot;释放资源..&quot;</span>)<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;抛出异常&quot;</span>)<br>fmt.Println(<span class="hljs-number">2</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">func func3() &#123;</span><br><span class="hljs-string">fmt.Println(&quot;</span><span class="hljs-number">3</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">func main() &#123;</span><br><span class="hljs-string">func1()</span><br><span class="hljs-string">func2()</span><br><span class="hljs-string">func3()</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>Java中的java.lang包下具体有什么在这里就不赘述了，请参考JavaAPI文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">JavaAPI文档导航：https:&#x2F;&#x2F;www.oracle.com&#x2F;cn&#x2F;java&#x2F;technologies&#x2F;java-se-api-doc.html<br></code></pre></td></tr></table></figure><h3 id="21-Go的标准格式化输出库fmt和java的输出打印库对比"><a href="#21-Go的标准格式化输出库fmt和java的输出打印库对比" class="headerlink" title="21.Go的标准格式化输出库fmt和java的输出打印库对比"></a>21.Go的标准格式化输出库fmt和java的输出打印库对比</h3><p>Java的标准输出流工具类是java.lang包下的System类，具体是其静态成员变量PrintStream类。</p><p>他有静态三个成员变量:</p><p>分别是PrintStream类型的out,in,err</p><p>我们常见System.out.println(),实际上调用的就是PrintStream类对象的println方法。</p><p>Go中的格式化输出输入库是fmt模块。</p><p>fmt在Go中提供了输入和输出的功能，类型Java中的Scanner和PrintStream(println)。</p><p>它的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Print:   原样输出到控制台，不做格式控制。<br>Println: 输出到控制台并换行<br>Printf : 格式化输出(按特定标识符指定格式替换)<br>Sprintf：格式化字符串并把字符串返回，不输出，有点类似于Java中的拼接字符串然后返回。<br>Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout<br></code></pre></td></tr></table></figure><p>详细占位符号如下：</p><p>代码示例如下：</p><h3 id="22-Go的面向对象相关知识"><a href="#22-Go的面向对象相关知识" class="headerlink" title="22.Go的面向对象相关知识"></a>22.Go的面向对象相关知识</h3><h4 id="1-封装属性-结构体"><a href="#1-封装属性-结构体" class="headerlink" title="1.封装属性(结构体)"></a>1.封装属性(结构体)</h4><p>Go中有一个数据类型是Struct,它在面向对象的概念中相当于Java的类，可以封装属性和封装方法，首先看封装属性如下示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//示例</span><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span> &#123;<br>   name <span class="hljs-keyword">string</span><br>   age <span class="hljs-keyword">int</span><br>   sex <span class="hljs-keyword">bool</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>   <span class="hljs-comment">//示例1：</span><br>   <span class="hljs-keyword">var</span> l1 People<br>   l1.name = <span class="hljs-string">&quot;li_ming&quot;</span><br>   l1.age = <span class="hljs-number">22</span><br>   l1.sex = <span class="hljs-literal">false</span><br>   <span class="hljs-comment">//li_ming</span><br>   fmt.Println(l1.name)<br><br>   <span class="hljs-comment">//示例2</span><br>   <span class="hljs-keyword">var</span> l2 *People = <span class="hljs-built_in">new</span>(People)<br>   l2.name = <span class="hljs-string">&quot;xiao_hong&quot;</span><br>   l2.age = <span class="hljs-number">33</span><br>   l2.sex = <span class="hljs-literal">true</span><br>   <span class="hljs-comment">//xiao_hong xiao_hong</span><br>   fmt.Println(l2.name,(*l2).name)<br><br>   <span class="hljs-comment">//示例3:</span><br>   <span class="hljs-keyword">var</span> l3 *People = &amp;People&#123; name:<span class="hljs-string">&quot;li_Ming&quot;</span>,age:<span class="hljs-number">25</span>,sex:<span class="hljs-literal">true</span>&#125;<br>   <span class="hljs-comment">//li_Ming  li_Ming</span><br>   fmt.Println(l3.name,(*l3).name)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-封装方法-方法接收器"><a href="#2-封装方法-方法接收器" class="headerlink" title="2.封装方法(方法接收器)"></a>2.封装方法(方法接收器)</h4><p>如果想为某个Struct类型添加一个方法，参考如下说明和代码：</p><p>go的方法和Java中的方法对比，go的函数和go方法的不同</p><p>Go中的函数是不需要用结构体的对象来调用的，可以直接调用</p><p>Go中的方法是必须用一个具体的结构体对象来调用的，有点像Java的某个类的对象调用其方法</p><p>我们可以把指定的函数绑定到对应的结构体上，使该函数成为这个结构体的方法，然后这个结构体的对象就可以通过.来调用这个方法了</p><p>绑定的形式是：在func和方法名之间写一个(当前对象变量名  当前结构体类型)，这个叫方法的接受器，其中当前对象的变量名就是当前结构体调用该方法的对象的引用，相当于java中的this对象。</p><p>参考如下示例为Student学生添加一个learn学习的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>  &#123;<br>   num <span class="hljs-keyword">int</span> <span class="hljs-comment">//学号</span><br>   name <span class="hljs-keyword">string</span> <span class="hljs-comment">//姓名</span><br>   class <span class="hljs-keyword">int</span>  <span class="hljs-comment">//班级</span><br>   sex  <span class="hljs-keyword">bool</span>  <span class="hljs-comment">//性别</span><br>&#125;<br><br><span class="hljs-comment">//给Student添加一个方法</span><br><span class="hljs-comment">//这里的(stu Student)中的stu相当于java方法中的this对象</span><br><span class="hljs-comment">//stu是一个方法的接收器，接收是哪个对象调用了当方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu Student)</span> <span class="hljs-title">learn</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;%s学生正在学习&quot;</span>,stu.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   stu := Student&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&quot;li_ming&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">true</span>&#125;<br>   stu.learn()<br>&#125;<br></code></pre></td></tr></table></figure><p>方法的接收器也可以是指针类型的</p><p>参考如下案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>  &#123;<br>   num <span class="hljs-keyword">int</span> <span class="hljs-comment">//学号</span><br>   name <span class="hljs-keyword">string</span> <span class="hljs-comment">//姓名</span><br>   class <span class="hljs-keyword">int</span>  <span class="hljs-comment">//班级</span><br>   sex  <span class="hljs-keyword">bool</span>  <span class="hljs-comment">//性别</span><br>&#125;<br><br><span class="hljs-comment">//这里方法的接收器也可以是指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span> <span class="hljs-title">learn</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;%s学生正在学习&quot;</span>,stu.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//指针类型</span><br>   stu := &amp;Student&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&quot;li_ming&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">true</span>&#125;<br>   stu.learn()<br>&#125;<br></code></pre></td></tr></table></figure><p>注意有一种情况，当一个对象为nil空时，它调用方法时，接收器接受的对于自身的引用也是nil，需要我们做一些健壮性的不为nil才做的判断处理。</p><h4 id="3-Go的继承-结构体嵌入"><a href="#3-Go的继承-结构体嵌入" class="headerlink" title="3.Go的继承(结构体嵌入)"></a>3.Go的继承(结构体嵌入)</h4><p>Go中可以用嵌入结构体实现类似于继承的功能：</p><p>参考如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//电脑</span><br><span class="hljs-keyword">type</span> Computer <span class="hljs-keyword">struct</span> &#123;<br>screen <span class="hljs-keyword">string</span> <span class="hljs-comment">//电脑屏幕</span><br>keyboard <span class="hljs-keyword">string</span> <span class="hljs-comment">//键盘</span><br>&#125;<br><br><span class="hljs-comment">//计算方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cp Computer)</span> <span class="hljs-title">compute</span><span class="hljs-params">(num1,num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>&#123;<br><span class="hljs-keyword">return</span> num1+num2;<br>&#125;<br><br><span class="hljs-comment">//笔记本电脑</span><br><span class="hljs-keyword">type</span> NoteBookComputer <span class="hljs-keyword">struct</span>&#123;<br>Computer<br>wireless_network_adapter <span class="hljs-keyword">string</span> <span class="hljs-comment">//无线网卡</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> cp1 NoteBookComputer = NoteBookComputer&#123;&#125;<br>cp1.screen = <span class="hljs-string">&quot;高清屏&quot;</span><br>cp1.keyboard = <span class="hljs-string">&quot;防水键盘&quot;</span><br>cp1.wireless_network_adapter = <span class="hljs-string">&quot;新一代无线网卡&quot;</span><br>fmt.Println(cp1)<br>fmt.Println(cp1.compute(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，Go中可以嵌入多个结构体，但是多个结构体不能有相同的方法，如果有参数和方法名完全相同的方法，在编译的时候就会报错。所以Go不存在嵌入多个结构体后，被嵌入的几个结构体有相同的方法，最后不知道选择执行哪个方法的情况，多个结构体方法相同时，直接编译就会报错。</p><p>参考如下示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   man := Man&#123;&#125;<br>   fmt.Println(man)<br>   <span class="hljs-comment">//下面的代码编译会报错</span><br>   <span class="hljs-comment">//man.doEat()</span><br><br>&#125;<br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>   FatherA<br>   FatherB<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p FatherA)</span>  <span class="hljs-title">doEat</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;FatherA eat&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t FatherB)</span>  <span class="hljs-title">doEat</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;FatherB eat&quot;</span>)<br>&#125;<br><br><br><span class="hljs-keyword">type</span> FatherB <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">type</span> FatherA <span class="hljs-keyword">struct</span>  &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Go的多态-接口"><a href="#4-Go的多态-接口" class="headerlink" title="4.Go的多态(接口)"></a>4.Go的多态(接口)</h4><p>接下来我们讲Go中如何通过父类接口指向具体实现类对象，实现多态：</p><p>go语言中的接口是非侵入式接口。</p><p>java语言中的接口是侵入式接口。</p><p>侵入式接口是指需要显示的在类中写明实现哪些接口。</p><p>非侵入式接口是指不要显示的在类中写明要实现哪些接口，只需要方法名同名，参数一致即可。</p><p>参考如下代码示例：接口与多态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//动物接口</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span>&#123;<br>   eat()     <span class="hljs-comment">//吃饭接口方法</span><br>   sleep()       <span class="hljs-comment">//睡觉接口方法</span><br>&#125;<br><span class="hljs-comment">//小猫</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//小狗</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//小猫吃方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cat Cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;小猫在吃饭&quot;</span>)<br>&#125;<br><span class="hljs-comment">//小猫睡方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cat Cat)</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;小猫在睡觉&quot;</span>)<br>&#125;<br><span class="hljs-comment">//小狗在吃饭</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;小狗在吃饭&quot;</span>)<br>&#125;<br><span class="hljs-comment">//小狗在睡觉</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;小狗在睡觉&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> cat Animal = Cat&#123;&#125;<br>   <span class="hljs-keyword">var</span> dog Animal = Dog&#123;&#125;<br>   cat.eat()<br>   cat.sleep()<br>   dog.eat()<br>   dog.sleep()<br>&#125;<br></code></pre></td></tr></table></figure><p>接口可以内嵌接口</p><p>参考如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//内嵌接口</span><br><span class="hljs-comment">//学习接口，内嵌听和看学习接口</span><br><span class="hljs-keyword">type</span> Learn <span class="hljs-keyword">interface</span> &#123;<br>   LearnByHear<br>   LearnByLook<br>&#125;<br><span class="hljs-comment">//通过听学习接口</span><br><span class="hljs-keyword">type</span> LearnByHear <span class="hljs-keyword">interface</span> &#123;<br>   hear()<br>&#125;<br><span class="hljs-comment">//通过看学习</span><br><span class="hljs-keyword">type</span> LearnByLook <span class="hljs-keyword">interface</span> &#123;<br>   look()<br>&#125;<br></code></pre></td></tr></table></figure><p>### </p><h3 id="23-Go语言中线程的实现和Java语言中线程的实现"><a href="#23-Go语言中线程的实现和Java语言中线程的实现" class="headerlink" title="23.Go语言中线程的实现和Java语言中线程的实现"></a>23.Go语言中线程的实现和Java语言中线程的实现</h3><p>go中的线程相关的概念是Goroutines(并发)，是使用go关键字开启。</p><p>Java中的线程是通过Thread类开启的。</p><p>在go语言中，一个线程就是一个Goroutines，主函数就是（主） main Goroutines。</p><p>使用go语句来开启一个新的Goroutines</p><p>比如：</p><p>普通方法执行</p><p>​    myFunction()</p><p>开启一个Goroutines来执行方法</p><p>​     go  myFunction()</p><p>java中是</p><p>​         new Thread(()-&gt;{ </p><p>​                //新线程逻辑代码</p><p>​         }).start();</p><p>参考下面的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">//并发开启新线程goroutine测试</span><br><br><span class="hljs-comment">//我的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello!!!&quot;</span>)<br>&#125;<br><span class="hljs-comment">//并发执行方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutineTestFunc</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello!!! Start Goroutine!!!&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   myFunction()</span><br><span class="hljs-comment">   //go goroutineTestFunc()</span><br><span class="hljs-comment">   //此时因为主线程有时候结束的快，goroutineTestFunc方法得不到输出，由此可以看出是开启了新的线程。</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-comment">//打开第二段执行</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   go goroutineTestFunc()</span><br><span class="hljs-comment">   time.Sleep(10*time.Second)//睡一段时间  10秒</span><br><span class="hljs-comment">   myFunction()</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>线程间的通信：</p><p>java线程间通信有很多种方式：</p><p>比如最原始的 wait/notify</p><p>到使用juc下高并发线程同步容器，同步队列</p><p>到CountDownLatch等一系列工具类</p><p>……</p><p>甚至是分布式系统不同机器之间的消息中间件，单机的disruptor等等。</p><p>Go语言不同，线程间主要的通信方式是Channel。</p><p>Channel是实现go语言多个线程（goroutines）之间通信的一个机制。</p><p>Channel是一个线程间传输数据的管道，创建Channel必须声明管道内的数据类型是什么</p><p>下面我们创建一个传输int类型数据的Channel</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>   fmt.Println(ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>channel是引用类型，函数传参数时是引用传递而不是值拷贝的传递。</p><p>channel的空值和别的应用类型一样是nil。</p><p>==可以比较两个Channel之间传输的数据类型是否相等。</p><p>channel是一个管道，他可以收数据和发数据。</p><p>具体参照下面代码示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><span class="hljs-comment">//channel发送数据和接受数据用 &lt;-表示,是发送还是接受取决于chan在  &lt;-左边还是右边</span><br><span class="hljs-comment">//创建一个传输字符串数据类型的管道</span><br><span class="hljs-keyword">var</span>  chanStr  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;main goroutine print Hello &quot;</span>)<br>   <span class="hljs-comment">//默认channel是没有缓存的，阻塞的，也就是说，发送端发送后直到接受端接受到才会施放阻塞往下面走。</span><br>   <span class="hljs-comment">//同样接收端如果先开启，直到接收到数据才会停止阻塞往下走</span><br>   <span class="hljs-comment">//开启新线程发送数据</span><br>   <span class="hljs-keyword">go</span> startNewGoroutineOne()<br>   <span class="hljs-comment">//从管道中接收读取数据</span><br>   <span class="hljs-keyword">go</span> startNewGoroutineTwo()<br>   <span class="hljs-comment">//主线程等待，要不直接结束了</span><br>   time.Sleep(<span class="hljs-number">100</span>*time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startNewGoroutineOne</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;send channel print Hello &quot;</span>)<br>   <span class="hljs-comment">//管道发送数据</span><br>   chanStr &lt;- <span class="hljs-string">&quot;Hello!!!&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startNewGoroutineTwo</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;receive channel print Hello &quot;</span>)<br>   strVar := &lt;-chanStr<br>   fmt.Println(strVar)<br>&#125;<br></code></pre></td></tr></table></figure><p>无缓存的channel可以起到一个多线程间线程数据同步锁安全的作用。</p><p>缓存的channel创建方式是</p><p>make(chan string,缓存个数)</p><p>缓存个数是指直到多个数据没有消费或者接受后才进行阻塞。</p><p>类似于java中的synchronized和lock</p><p>可以保证多线程并发下的数据一致性问题。</p><p>首先我们看一个线程不安全的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//多线程并发下的不安全问题</span><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA <span class="hljs-keyword">int</span> =<span class="hljs-number">1000</span><br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> moneyA;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>   &#125;()<br>   <span class="hljs-comment">//正常逻辑，只够扣款一单，可以多线程环境下结果钱扣多了</span><br>   time.Sleep(<span class="hljs-number">5</span>*time.Second)<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存为1的channel可以作为锁使用：</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//多线程并发下使用channel改造</span><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA  = <span class="hljs-number">1000</span><br><span class="hljs-comment">//减少金额管道</span><br><span class="hljs-keyword">var</span> synchLock = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> moneyA;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>      &lt;-synchLock<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>   &#125;()<br>   <span class="hljs-comment">//这样类似于java中的Lock锁，不会扣多</span><br>   time.Sleep(<span class="hljs-number">5</span>*time.Second)<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><p>go也有互斥锁</p><p>类似于java中的Lock接口</p><p>参考如下示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//多线程并发下使用channel改造</span><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA  = <span class="hljs-number">1000</span><br><br><span class="hljs-keyword">var</span> lock sync.Mutex;<br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   lock.Lock()<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>   lock.Unlock()<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   lock.Lock()<br>   result := moneyA<br>   lock.Unlock()<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;余额不足，无法扣款&quot;</span>)<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;余额不足，无法扣款&quot;</span>)<br>      &#125;<br>   &#125;()<br>   <span class="hljs-comment">//正常</span><br>   time.Sleep(<span class="hljs-number">5</span>*time.Second)<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24-Go中的反射与Java中的反射对比"><a href="#24-Go中的反射与Java中的反射对比" class="headerlink" title="24.Go中的反射与Java中的反射对比"></a>24.Go中的反射与Java中的反射对比</h3><p>​        整体概述：反射是一个通用的概念，是指在程序运行期间获取到变量或者对象，结构体的元信息，比如类型信息，并且能够取出其中变量的值，调用对应的方法。</p><p>​      首先我们先来回顾一下Java语言用到反射的场景有哪些？</p><p>​      1.比如说我们的方法参数不能确定是什么类型，是Object类型，我们就可以通过反射在运行期间获取其真实的类型，然后做对应的逻辑处理。</p><p>​      2.比如动态代理，我们需要在程序运行时，动态的加载一个类，创建一个类，使用一个类。</p><p>​      3.比如在想要强行破解获取程序中被private的成员。</p><p>​      4.Java的各种框架中用的非常多，框架中用反射来判断用户自定义的类是什么类型，然后做区别处理。</p><p>​    </p><p>​      Go中的反射大概也是相同的，比如，go中有一个类型 interface,interface类型相当于Java中的Object类，当以interface作为参数类型时，可以给这个参数传递任意类型的变量。</p><p>​      例如示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   testAllType(<span class="hljs-number">1</span>);<br>   testAllType(<span class="hljs-string">&quot;Go&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//interface&#123;&#125;代表任意类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testAllType</span> <span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>&#123;<br>   fmt.Println(data)<br>&#125;<br></code></pre></td></tr></table></figure><p>​     那么第一种应用场景就出现了，当我们在go中想实现一个函数/方法，这个函数/方法的参数类型在编写程序的时候不能确认，在运行时会有各种不同的类型传入这个通用的函数/方法中，我们需要对不同类型的参数做不同的处理，那么我们就得能获取到参数是什么类型的，然后根据这个类型信息做业务逻辑判断。</p><p>​      反射我们需要调用reflect包模块,使用reflect.typeOf()可以获取参数的类型信息对象，再根据类型信息对象的kind方法，获取到具体类型，详细参考下面代码。</p><p>​      例如示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   handleType(<span class="hljs-number">1</span>)<br>   handleType(<span class="hljs-literal">true</span>)<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleType</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>   <span class="hljs-comment">//获取类型对象</span><br>   d := reflect.TypeOf(data)<br>   <span class="hljs-comment">//kind方法是获取类型</span><br>   fmt.Println(d.Kind())<br>   <span class="hljs-keyword">switch</span> d.Kind() &#123;<br>      <span class="hljs-keyword">case</span> reflect.Invalid:<br>         <span class="hljs-comment">//无效类型逻辑处理</span><br>         fmt.Println(<span class="hljs-string">&quot;无效类型&quot;</span>)<br>      <span class="hljs-keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:<br>         fmt.Println(<span class="hljs-string">&quot;整形&quot;</span>)<br>      <span class="hljs-keyword">case</span> reflect.Bool:<br>         fmt.Println(<span class="hljs-string">&quot;bool类型&quot;</span>)<br>   &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><pre><code>      因为传入进来的都是interface类型，所以我们需要用的时候要区分类型，然后取出其中真正类型的值。</code></pre><p>​          反射取出值得方法就是先通过reflect.ValueOf()获取参数值对象，然后再通过不同的具体方法获取到值对象，比如int和bool</p><p>​          示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>handleValue(<span class="hljs-number">1</span>)<br>handleValue(<span class="hljs-literal">true</span>)<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleValue</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-comment">//获取类型对象</span><br>d := reflect.ValueOf(data)<br><span class="hljs-comment">//kind方法是获取类型</span><br>fmt.Println(d.Kind())<br><span class="hljs-keyword">switch</span> d.Kind() &#123;<br><span class="hljs-keyword">case</span> reflect.Invalid:<br><span class="hljs-comment">//无效类型逻辑处理</span><br>fmt.Println(<span class="hljs-string">&quot;无效类型&quot;</span>)<br><span class="hljs-keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:<br><span class="hljs-comment">//取出值</span><br><span class="hljs-keyword">var</span> myNum = d.Int()<br>fmt.Println(myNum)<br><span class="hljs-keyword">case</span> reflect.Bool:<br><span class="hljs-comment">//取出bool值</span><br><span class="hljs-keyword">var</span> myBool = d.Bool()<br>fmt.Println(myBool)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​        结构体中的属性和方法怎么获取呢？</p><p>​        获取结构体属性的个数是先ValueOf获取结构体值对象v后，用v.NumField()获取该结构体有几个属性，通过v.Field(i)来获取对应位置的属性的元类型。</p><p>​       示例代码4：</p><p>​       后续反射还有几个api和代码示例和具体应用场景，正在补。。。</p><h3 id="25-变量作用域的区别"><a href="#25-变量作用域的区别" class="headerlink" title="25.变量作用域的区别"></a>25.变量作用域的区别</h3><p>​            Go语言的变量作用域和Java中的一样，遵循最近原则，逐渐往外层找。</p><p>​            这个比较简单，就不做过多赘述了。    </p><h3 id="26-Go语言和Java语言字符串操作的区别"><a href="#26-Go语言和Java语言字符串操作的区别" class="headerlink" title="26.Go语言和Java语言字符串操作的区别"></a>26.Go语言和Java语言字符串操作的区别</h3><h3 id="27-Go语言和Java语言IO操作的区别"><a href="#27-Go语言和Java语言IO操作的区别" class="headerlink" title="27.Go语言和Java语言IO操作的区别"></a>27.Go语言和Java语言IO操作的区别</h3><h3 id="28-Go语言中有匿名函数，有闭包，Java中没有-高阶函数用法"><a href="#28-Go语言中有匿名函数，有闭包，Java中没有-高阶函数用法" class="headerlink" title="28.Go语言中有匿名函数，有闭包，Java中没有(高阶函数用法)"></a>28.Go语言中有匿名函数，有闭包，Java中没有(高阶函数用法)</h3><p>函数也是一种类型，它可以作为一个参数进行传递，也可以作为一个返回值传递。</p><p>Go中可以定义一个匿名函数，并把这个函数赋值给一个变量</p><p>示例1： 匿名函数赋值给变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义一个匿名函数并赋值给myFun变量</span><br><span class="hljs-keyword">var</span> myFun = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> x+y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//调用myFun</span><br>   fmt.Println(myFun(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><p>Go的函数内部是无法再声明一个有名字的函数的，Go的函数内部只能声明匿名函数。</p><p>示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   myFunc3()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFun1</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*此处报错，函数内部不能声明带有名称的函数</span><br><span class="hljs-comment">   func myFunc2() &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc3</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//函数内部可以声明一个匿名函数，并把这个匿名函数赋值给f变量</span><br>   <span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Hi,boy!&quot;</span>)<br>   &#125;<br>   <span class="hljs-comment">//调用f</span><br>   f()<br>   <span class="hljs-comment">//如果不想赋值给变量，那就必须在最后加上(),表示立即执行</span><br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;Hello,girl!&quot;</span>)<br>   &#125;()<span class="hljs-comment">//有参数可以写在这个小括号中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Hi,boy!<br>Hello,girl!<br></code></pre></td></tr></table></figure><p>Go中有闭包的功能。(闭包是一个通用的编程概念，一些语言有，一些没有，javascript中就有这个概念，Java中没有)</p><p>闭包,通俗易懂的讲，就是你有一个A函数，A函数有一个a参数，然后在A函数内部再定义或者调用或者写一个B函数，这个B函数叫做闭包函数。B函数内部的代码可以访问它外部的A函数的a参数，正常A函数调用返回完毕，a参数就不能用了，可是闭包函数B函数仍然可以访问这个a参数，B函数能不受A函数的调用生命周期限制可以随时访问其中的a参数，这个能访问的状态叫做已经做了闭包，闭包闭的是把a参数封闭到了B函数中，不受A函数的限制。</p><p>也就是说，我们用程序实现一个闭包的功能，实质上就是写一个让外层的函数参数或者函数内变量封闭绑定到内层函数的功能。</p><p>接下来我们看代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//我们来看看实现闭包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> f = f1(<span class="hljs-number">100</span>)<br>   f(<span class="hljs-number">100</span>) <span class="hljs-comment">//print 200</span><br>   f(<span class="hljs-number">100</span>) <span class="hljs-comment">//print 300</span><br>   f(<span class="hljs-number">100</span>) <span class="hljs-comment">//print 400</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>&#123;<br>   <span class="hljs-comment">//此时即使f1函数执行完毕，x也不会消失</span><br>   <span class="hljs-comment">//x在func(y int)这个函数内一直存在并且叠加，</span><br>   <span class="hljs-comment">//这里把x的值封闭到func(y int)这个返回函数中，使其函数一直能使用x的值</span><br>   <span class="hljs-comment">//就叫做闭包，把x变量封闭到fun(y int)这个函数包内。</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span></span>&#123;<br>      x+=y<br>      fmt.Printf(<span class="hljs-string">&quot;x=%d\n&quot;</span>,x)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">x&#x3D;200<br>x&#x3D;300<br>x&#x3D;400<br></code></pre></td></tr></table></figure><p>做下闭包的总结，如何实现一个闭包：</p><p>1.定义一个A函数，此函数返回一个匿名函数。（定义一个返回匿名函数的A函数）</p><p>2.把在A函数的b参数或A函数代码块中的b变量，放入匿名函数中，进行操作。</p><p>3.这样我们调用A函数返回一个函数，这个函数不断的调用就可以一直使用之前b参数，b变量，并且b值不会刷新，有点像在匿名函数外部自定义了一个b的成员变量（成员变量取自Java中类的相关概念）</p><h3 id="29-Go中的map和Java中的HashMap"><a href="#29-Go中的map和Java中的HashMap" class="headerlink" title="29.Go中的map和Java中的HashMap"></a>29.Go中的map和Java中的HashMap</h3><p>Go中的map也是一个存储key-value，键值对的这么一种数据结构。</p><p>我们来看下如何使用：</p><p>如何创建一个map?(map是引用类型，默认值是nil，必须用make为其创建才能使用)</p><p>创建一个map必须要用make，否则会是nil</p><p>格式为:  make(map[key类型]value类型) (下面有代码示例)</p><p>往Go中的map赋值添加元素用 【 map变量名称[key] = value 】 的方式</p><p>示例1：创建map以及添加元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个map必须要用make，否则会是nil</span><br>   <span class="hljs-comment">//格式为:  make(map[key类型]value类型)</span><br>   <span class="hljs-comment">//Java中:   Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span><br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>   <span class="hljs-comment">//往Go中的map赋值添加元素用 【 map变量名称[key] = value 】 的方式</span><br>   <span class="hljs-comment">//区别于Java中的: myMap.put(&quot;li_age&quot;,20);</span><br>   myMap[<span class="hljs-string">&quot;li_age&quot;</span>] = <span class="hljs-number">20</span><br>   myMap[<span class="hljs-string">&quot;hong_age&quot;</span>] = <span class="hljs-number">30</span><br>   <span class="hljs-comment">//打印一下map</span><br>   fmt.Println(myMap)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们从map中取值得格式为：   【  mapValue  := map变量名[key]】</p><p>当我们填写的key在map中找不到时返回对应的value默认值，int是0，引用类型是nil</p><p>当我们的key取不到对应的值，而value的类型是一个int类型，我们如何判断这个0是实际值还是默认值呢</p><p>此时我们需要同时取两个值</p><p>通过map的key取出两个值，第二个参数为bool类型，false为该值不存在，true为成功取到值</p><p>参考下面：</p><p>示例2：从map中取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个map必须要用make，否则会是nil</span><br>   <span class="hljs-comment">//格式为:  make(map[key类型]value类型)</span><br>   <span class="hljs-comment">//Java中:   Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span><br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>   <span class="hljs-comment">//往Go中的map赋值添加元素用 【 map变量名称[key] = value 】 的方式</span><br>   <span class="hljs-comment">//区别于Java中的: myMap.put(&quot;li_age&quot;,20);</span><br>   myMap[<span class="hljs-string">&quot;li_age&quot;</span>] = <span class="hljs-number">20</span><br>   myMap[<span class="hljs-string">&quot;hong_age&quot;</span>] = <span class="hljs-number">30</span><br>   <span class="hljs-comment">//打印一下map</span><br>   fmt.Println(myMap)<br>   <span class="hljs-comment">//不存在的值</span><br>   fmt.Println(myMap[<span class="hljs-string">&quot;no&quot;</span>])<br><br>   <span class="hljs-comment">//当我们的key取不到对应的值，而value的类型是一个int类型，我们如何判断这个0是实际值还是默认值呢</span><br>   <span class="hljs-comment">//此时我们需要同时取两个值</span><br>   <span class="hljs-comment">//通过map的key取出两个值，第二个参数为bool类型，false为该值不存在，true为成功取到值</span><br>   value,existsValue := myMap[<span class="hljs-string">&quot;no&quot;</span>]<br>   <span class="hljs-keyword">if</span> !existsValue &#123;<br>      fmt.Println(<span class="hljs-string">&quot;此值不存在&quot;</span>)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;value = %d&quot;</span>,value)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Go中因为返回值可以是两个，所以的map遍历很简单，不像java还得弄一个Iterator对象再逐个获取，它一次两个都能取出来，用for搭配range即可实现。</p><p>示例3：遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>   myMap[<span class="hljs-string">&quot;num1&quot;</span>] = <span class="hljs-number">1</span><br>   myMap[<span class="hljs-string">&quot;num2&quot;</span>] = <span class="hljs-number">2</span><br>   myMap[<span class="hljs-string">&quot;num3&quot;</span>] = <span class="hljs-number">3</span><br>   myMap[<span class="hljs-string">&quot;num4&quot;</span>] = <span class="hljs-number">4</span><br>   myMap[<span class="hljs-string">&quot;num5&quot;</span>] = <span class="hljs-number">5</span><br>   myMap[<span class="hljs-string">&quot;num6&quot;</span>] = <span class="hljs-number">6</span><br>   <span class="hljs-comment">//遍历key,value</span><br>   <span class="hljs-keyword">for</span> key,value := <span class="hljs-keyword">range</span> myMap &#123;<br>      fmt.Println(key,value)<br>   &#125;<br>   <span class="hljs-comment">//写一个参数的时候只取key</span><br>   <span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> myMap &#123;<br>      fmt.Println(key)<br>   &#125;<br>   <span class="hljs-comment">//如果只想取value，就需要用到之前的_标识符进行占位丢弃</span><br>   <span class="hljs-keyword">for</span> _,value := <span class="hljs-keyword">range</span> myMap &#123;<br>      fmt.Println(value)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除函数：用内置函数delete删除</p><p>示例4：删除map元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>   myMap[<span class="hljs-string">&quot;num1&quot;</span>] = <span class="hljs-number">1</span><br>   myMap[<span class="hljs-string">&quot;num2&quot;</span>] = <span class="hljs-number">2</span><br>   myMap[<span class="hljs-string">&quot;num3&quot;</span>] = <span class="hljs-number">3</span><br>   myMap[<span class="hljs-string">&quot;num4&quot;</span>] = <span class="hljs-number">4</span><br>   myMap[<span class="hljs-string">&quot;num5&quot;</span>] = <span class="hljs-number">5</span><br>   myMap[<span class="hljs-string">&quot;num6&quot;</span>] = <span class="hljs-number">6</span><br>   <span class="hljs-comment">//第二个参数为删除的key</span><br>   <span class="hljs-built_in">delete</span>(myMap,<span class="hljs-string">&quot;num6&quot;</span>)<br>   <span class="hljs-comment">//此时已经没有值了，默认值为0</span><br>   fmt.Println(myMap[<span class="hljs-string">&quot;num6&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中有一些复杂的Map类型，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Map&lt;String,Map&lt;String,Object&gt;&gt; data &#x3D; new HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><p>实际上，在Go语言中，也有复杂的类型，我们举几个代码示例</p><p>示例5：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//由map组成的切片</span><br>   <span class="hljs-comment">//第一部分 make[] 声明切片</span><br>   <span class="hljs-comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span><br>   <span class="hljs-comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span><br>   <span class="hljs-comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span><br>   <span class="hljs-comment">//容量至少比长度大，能索引到几个+未来可添加元素个数(目前没有任何东西，看不见)= 切片容量</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度，切片容量)</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度和容量等同)</span><br>   slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>   slice0 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>   <span class="hljs-comment">//我们看看打印的东西</span><br>   fmt.Println(<span class="hljs-string">&quot;slice=&quot;</span>,slice)<br>   fmt.Println(<span class="hljs-string">&quot;slice=0&quot;</span>,slice0)<br><br>   <span class="hljs-comment">///*   先看这段</span><br>   <span class="hljs-comment">//因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span><br>   <span class="hljs-comment">//slice[0][&quot;age&quot;] = 10;//报错</span><br>   <span class="hljs-comment">//下面不报错</span><br>   slice[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">10</span>)<br>   slice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">19</span><br>   fmt.Println(slice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;age&quot;</span>])<br>   <span class="hljs-comment">//*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">slice&#x3D; [map[] map[] map[] map[] map[]]<br>slice&#x3D;0 []<br>19<br></code></pre></td></tr></table></figure><p>接下来继续看代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//由map组成的切片</span><br>   <span class="hljs-comment">//第一部分 make[] 声明切片</span><br>   <span class="hljs-comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span><br>   <span class="hljs-comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span><br>   <span class="hljs-comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span><br>   <span class="hljs-comment">//append元素到切片时，是添加到最末尾的位置，当元素未超过容量时，都是用的同一个底层数组</span><br>   <span class="hljs-comment">//超过容量时会返回一个新的数组</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度，切片容量)</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度和容量等同)</span><br>   slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>   slice0 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>   <span class="hljs-comment">//我们看看打印的东西</span><br>   fmt.Println(<span class="hljs-string">&quot;slice=&quot;</span>,slice)<br>   fmt.Println(<span class="hljs-string">&quot;slice=0&quot;</span>,slice0)<br><br>   <span class="hljs-comment">/*   先看这段</span><br><span class="hljs-comment">   //因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span><br><span class="hljs-comment">   //slice[0][&quot;age&quot;] = 10;//报错</span><br><span class="hljs-comment">   //下面不报错</span><br><span class="hljs-comment">   slice[0] = make(map[string]int,10)</span><br><span class="hljs-comment">   slice[0][&quot;age&quot;] = 19</span><br><span class="hljs-comment">   fmt.Println(slice[0][&quot;age&quot;])</span><br><span class="hljs-comment">   */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">panic: assignment to entry in nil map<br></code></pre></td></tr></table></figure><p>看下面这个报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//由map组成的切片</span><br>   <span class="hljs-comment">//第一部分 make[] 声明切片</span><br>   <span class="hljs-comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span><br>   <span class="hljs-comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span><br>   <span class="hljs-comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span><br>   <span class="hljs-comment">//append元素到切片时，是添加到最末尾的位置，当元素未超过容量时，都是用的同一个底层数组</span><br>   <span class="hljs-comment">//超过容量时会返回一个新的数组</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度，切片容量)</span><br>   <span class="hljs-comment">//make([]切片类型,切片长度和容量等同)</span><br>   slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>   slice0 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>   <span class="hljs-comment">//我们看看打印的东西</span><br>   fmt.Println(<span class="hljs-string">&quot;slice=&quot;</span>,slice)<br>   fmt.Println(<span class="hljs-string">&quot;slice=0&quot;</span>,slice0)<br><br>   <span class="hljs-comment">/*   先看这段</span><br><span class="hljs-comment">   //因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span><br><span class="hljs-comment">   //slice[0][&quot;age&quot;] = 10;//报错</span><br><span class="hljs-comment">   //下面不报错</span><br><span class="hljs-comment">   slice[0] = make(map[string]int,10)</span><br><span class="hljs-comment">   slice[0][&quot;age&quot;] = 19</span><br><span class="hljs-comment">   fmt.Println(slice[0][&quot;age&quot;])</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-comment">///*</span><br>   <span class="hljs-comment">//因为初始化了0个长度，所以索引取不到值，报index out of range</span><br>   slice0[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">10</span>;<br><br>   <span class="hljs-comment">//*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">slice&#x3D; [mappanic: runtime error: index out of range<br></code></pre></td></tr></table></figure><p>接下来我们看一个：类似于Java中常用的map类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//类似于Java中的Map&lt;String,HashMap&lt;String,Object&gt;&gt;</span><br>   <span class="hljs-keyword">var</span> myMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;,<span class="hljs-number">10</span>)<br>   fmt.Println(myMap)<br>   <span class="hljs-comment">//记得make</span><br>   myMap[<span class="hljs-string">&quot;li_ming_id_123&quot;</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;,<span class="hljs-number">5</span>)<br>   myMap[<span class="hljs-string">&quot;li_ming_id_123&quot;</span>][<span class="hljs-string">&quot;school&quot;</span>] = <span class="hljs-string">&quot;清华大学&quot;</span><br><br>   fmt.Println(myMap)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">map[]<br>map[li_ming_id_123:map[school:清华大学]]<br></code></pre></td></tr></table></figure><h3 id="30-Go中的time时间包模块和Java中的时间API使用区别"><a href="#30-Go中的time时间包模块和Java中的时间API使用区别" class="headerlink" title="30.Go中的time时间包模块和Java中的时间API使用区别"></a>30.Go中的time时间包模块和Java中的时间API使用区别</h3><p>Go中关于时间处理的操作在time包中</p><p>1.基本获取时间信息</p><p>参考如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前时间</span><br>   now := time.Now()<br>   <span class="hljs-comment">//获取当前年份</span><br>   year := now.Year()<br>   <span class="hljs-comment">//获取当前月份</span><br>   month := now.Month()<br>   <span class="hljs-comment">//获取当前 日期</span><br>   day := now.Day()<br>   <span class="hljs-comment">//获取当前小时</span><br>   hour := now.Hour()<br>   <span class="hljs-comment">//获取当前分钟</span><br>   min := now.Minute()<br>   <span class="hljs-comment">//获取当前秒</span><br>   second :=now.Second()<br><br>   <span class="hljs-comment">//获取当前时间戳，和其它编程语言一样，自1970年算起</span><br>   timestamp := now.Unix()<br>   <span class="hljs-comment">//纳秒时间戳</span><br>   ntimestamp := now.UnixNano()<br><br><br>   fmt.Println(<span class="hljs-string">&quot;year=&quot;</span>,year)<br>   fmt.Println(<span class="hljs-string">&quot;month=&quot;</span>,month)<br>   fmt.Println(<span class="hljs-string">&quot;day=&quot;</span>,day)<br>   fmt.Println(<span class="hljs-string">&quot;hour=&quot;</span>,hour)<br>   fmt.Println(<span class="hljs-string">&quot;min=&quot;</span>,min)<br>   fmt.Println(<span class="hljs-string">&quot;second=&quot;</span>,second)<br>   fmt.Println(<span class="hljs-string">&quot;timestamp=&quot;</span>,timestamp)<br>   fmt.Println(<span class="hljs-string">&quot;ntimestamp=&quot;</span>,ntimestamp)<br>&#125;<br></code></pre></td></tr></table></figure><p>2.格式化时间</p><p>Go的时间格式化和其它语言不太一样，它比较特殊，取了go的出生日期作为参数标准</p><p>参考如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前时间</span><br>   now := time.Now()<br><br>   <span class="hljs-comment">//2006-01-02 15:04:05这个数值是一个标准写死的，只要改格式符号即可</span><br>   fmt.Println(now.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>   fmt.Println(now.Format(<span class="hljs-string">&quot;2006/01/02 15:04:05&quot;</span>))<br>   fmt.Println(now.Format(<span class="hljs-string">&quot;2006/01/02&quot;</span>))<span class="hljs-comment">//年月日</span><br>   fmt.Println(now.Format(<span class="hljs-string">&quot;15:04:05&quot;</span>))<span class="hljs-comment">//时分秒</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31-Go和Java关于Socket编程的对比"><a href="#31-Go和Java关于Socket编程的对比" class="headerlink" title="31.Go和Java关于Socket编程的对比"></a>31.Go和Java关于Socket编程的对比</h3><h3 id="32-聊聊Go语言如何连接Mysql数据库"><a href="#32-聊聊Go语言如何连接Mysql数据库" class="headerlink" title="32.聊聊Go语言如何连接Mysql数据库"></a>32.聊聊Go语言如何连接Mysql数据库</h3><h3 id="33-聊聊Go语言如何使用Redis"><a href="#33-聊聊Go语言如何使用Redis" class="headerlink" title="33.聊聊Go语言如何使用Redis"></a>33.聊聊Go语言如何使用Redis</h3><h3 id="34-Go中的依赖管理–Module-对比Java的maven"><a href="#34-Go中的依赖管理–Module-对比Java的maven" class="headerlink" title="34.Go中的依赖管理–Module,对比Java的maven"></a>34.Go中的依赖管理–Module,对比Java的maven</h3><h3 id="35-Go的协程高并发支持与Java的区别"><a href="#35-Go的协程高并发支持与Java的区别" class="headerlink" title="35.Go的协程高并发支持与Java的区别"></a>35.Go的协程高并发支持与Java的区别</h3><h3 id="36-Go的性能调优和Java的性能调优"><a href="#36-Go的性能调优和Java的性能调优" class="headerlink" title="36.Go的性能调优和Java的性能调优"></a>36.Go的性能调优和Java的性能调优</h3><h3 id="37-Go的测试API与Java的单元测试"><a href="#37-Go的测试API与Java的单元测试" class="headerlink" title="37.Go的测试API与Java的单元测试"></a>37.Go的测试API与Java的单元测试</h3><h3 id="38-自定义类型Type"><a href="#38-自定义类型Type" class="headerlink" title="38.自定义类型Type"></a>38.自定义类型Type</h3><h3 id="39-Go的参数值传递与引用传递"><a href="#39-Go的参数值传递与引用传递" class="headerlink" title="39.Go的参数值传递与引用传递"></a>39.Go的参数值传递与引用传递</h3><p>接下来我们讲一下Go中的参数传递原理。</p><p>关于参数传递是一个什么概念呢，参数传递相关的知识是在研究当调用一个函数时，把外部的一个变量传入函数内，在函数内修改这个参数是否会对外部的参数变量的值有影响。参数传递用在的一个地方是函数的参数传递。（还有方法的接收器参数传递）</p><p>比如李明今天没有写作业，到了学校后匆匆忙忙的找小红要作业本(小红的作业本为方法调用处传入的参数)，想要抄一抄补上，所以李明有一个抄作业的任务(抄作业的任务为函数)，那么他有两个选择可以完成抄作业的任务。</p><p>第一个是直接拿过来小红的作业本开始抄，这在函数中叫做引用传递，因为如果小明抄的时候不小心桌子上的水打翻了，弄湿了小红的作业本，小红的作业本就真湿了，没法交了。</p><p>第二个是用打印机把小红的作业打印一份，然后拿着打印的那份抄，这叫做值传递，也就是说我拷贝一份值来用，那么我在抄作业(任务函数内)无论怎么弄湿小红的作业本，小红真正的自己的作业本也不受到影响。</p><p>在编程语言的函数中，如果是值传递，则是一个拷贝，在方法内部修改该参数值无法对其本身造成影响，如果是引用传递的概念，则可以改变其对象本身的值。</p><p>在Go语言中只有值传递，也是是说，无论如何Go的参数传递的都是一个拷贝。</p><p>重点来了：</p><p>Go中的值传递有两种类型，如下：</p><p>1.第一种值传递是具体的类型对象值传递，可能是int,string,struct之类的。</p><pre><code>    在此时，如果我们要自定义一个struct类型，传入参数中，可能遇到一个坑，因为是值传递，所以会拷贝一个struct对象，如果这个对象占内存比较大，而且这个函数调用频繁，会大量的拷贝消耗性能资源。</code></pre><p>2.第二种传递是叫指针参数类型的值传递，此时参数是一个指针类型，到具体的方法中，我们的参数也要用指针类型的参数接受，但是此时Go语言的内部做了一个黑箱操作。</p><p>举例(下面还有完整可执行代码示例，先文字和伪代码举例)：</p><p>我们有一个类型为Boy的结构体,还有一个方法Mod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">func Mod(b  *Boy)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个Mod方法的参数是一个指针类型的Boy对象，</p><p>我们要调用的时候应该这样传参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">var boy &#x3D; Boy&#123;&#125; <br>&#x2F;&#x2F;用&amp;取boy对象的指针地址，然后传入Mod方法<br>Mod(&amp;boy)<br></code></pre></td></tr></table></figure><p>我们看看下面的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Boy 结构体</span><br><span class="hljs-keyword">type</span> Boy <span class="hljs-keyword">struct</span> &#123;<br>   name <span class="hljs-keyword">string</span><br>   age <span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Mod</span><span class="hljs-params">(b *Boy)</span></span> &#123;<br>   <span class="hljs-comment">//这个是获取调用方法传入的参数的地址值</span><br>   fmt.Printf(<span class="hljs-string">&quot;b的值(之前boy的地址)是%p\n&quot;</span>,b)<br>   <span class="hljs-comment">//这个是获取本函数中 b这个指针变量的地址</span><br>   fmt.Printf(<span class="hljs-string">&quot;b这个指针自己的地址是=%p\n&quot;</span>,&amp;b)<br>   <span class="hljs-comment">//打印值</span><br>   <span class="hljs-comment">//这里自动转换使指针可以直接点出来属性</span><br>   fmt.Println(b.name,b.age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    boy := Boy&#123;<span class="hljs-string">&quot;li_ming&quot;</span>,<span class="hljs-number">20</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;main函数中的boy地址是:%p\n&quot;</span>,&amp;boy)<br>    <span class="hljs-comment">//将boy的地址 放入Mod函数的参数中</span><br>    Mod(&amp;boy)<br>    <span class="hljs-comment">//注意！！！下面有黑箱操作：</span><br>    <span class="hljs-comment">/* //在&amp;boy并放入Mod传递的过程中实际上做了如下黑箱操作</span><br><span class="hljs-comment">    b := new(Boy)   //创建一个名为b的类型为Boy的指针变量</span><br><span class="hljs-comment">    b = &amp;boy      //把boy的地址存入b这个指针变量内</span><br><span class="hljs-comment">    //接着把b放入func Mod(b *Boy)的参数中，然后，开始执行Mod方法。</span><br><span class="hljs-comment">    fmt.Println(b.name,b.age)</span><br><span class="hljs-comment">    fmt.Printf(&quot;b的地址是:%p\n&quot;,&amp;b)</span><br><span class="hljs-comment">    fmt.Printf(&quot;b的值是:%p\n&quot;,b)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    //输出结果</span><br><span class="hljs-comment">    //main函数中的boy地址是:0x10aec0c0</span><br><span class="hljs-comment">    //li_ming 20</span><br><span class="hljs-comment">    //b的地址是:0x10ae40f8</span><br><span class="hljs-comment">    //b的值是:0x10aec0c0</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/*//以下代码无用，是指为了加深理解new，可以试试输出结果</span><br><span class="hljs-comment">    boy2 := new(Boy)</span><br><span class="hljs-comment">    fmt.Printf(&quot;main函数中new的boy2地址是:%p\n&quot;,boy2)</span><br><span class="hljs-comment">    boy2.name = &quot;xiaohong&quot;</span><br><span class="hljs-comment">    boy2.age = 18</span><br><span class="hljs-comment">    Mod(boy2)</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 所以，Go中的参数传递所有的都是值传递，</p><p>只不过值传递中，值可以是指针类型，是创建了一个新的指针存储原来参数(这个参数是原对象的地址)的值。</p><p>所以你用原对象的地址改它的属性，是有点类似于引用类型传递的效果的。</p><p>为啥说指针类型也是值传递，因为他还是创建了一个新的指针对象，值传递就是拷贝，拷贝就得创建对象，只不过这个新的指针变量存储的值是原来的参数对象的地址。</p><p>最后总结一下：</p><p>​            1.Go的参数传递都是值传递。</p><p>​            2.指针类型的值传递可以改变原来对象的值。</p><p>​            3.make和new从底层原理上创建的所有对象都是指针对象，所以make和new创建出来的slice,map,chan或者其它任何对象都是指针传递，改变值后都可以使原来的对象属性发生变化。</p><h3 id="40-结构体转JSON"><a href="#40-结构体转JSON" class="headerlink" title="40.结构体转JSON"></a>40.结构体转JSON</h3><h3 id="41-Go如何搭建HTTP-Server"><a href="#41-Go如何搭建HTTP-Server" class="headerlink" title="41.Go如何搭建HTTP-Server"></a>41.Go如何搭建HTTP-Server</h3><h3 id="42-Go如何搭建HTTP-Client"><a href="#42-Go如何搭建HTTP-Client" class="headerlink" title="42.Go如何搭建HTTP-Client"></a>42.Go如何搭建HTTP-Client</h3><h3 id="43-Go如何设置使用的CPU个数"><a href="#43-Go如何设置使用的CPU个数" class="headerlink" title="43.Go如何设置使用的CPU个数"></a>43.Go如何设置使用的CPU个数</h3><p>Go语言天生支持高并发，其中一个体现就是如果你的Go程序不设置并发时使用的最大cpu核数的话，在高并发情况下Go会自动把所有CPU都用上，跑满。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">拓展阅读：<br>我们简单理解一下cpu（懂得可以跳过）<br>    举例：比如有一个专门做财务的公司(计算机)，他们的赚钱业务很简单(计算机工作)，就是帮别人做算术题(计算机工作的具体任务)，加减乘除之类的算术题，现在公司有4个员工(物理意义上的4个cpu核数)，有4本算数书(4个进程)，每本书有10道题(线程)，一共有40道算术题要算(40个线程任务)，于是4个人一起干活，在同一时间，有4道算术题被计算，最后大致上每个人算了10道算数题。<br>    第二天，有8本算术书(8个进程)，他们为了快速完成任务，规定一人(每个人是一个物理cpu核数)管2本算数书(单物理cpu内部实际上是管理的两个不同的算数书，也就是相当于有两个不同的逻辑cpu)，为的就是如果第一本做烦了可以换着做第2本，混合着做，最后都做完就可以。<br><br>    cpu是进行最终二进制计算的核心计算器，cpu核数是有两个概念，一个是真实世界的物理硬件核数，比如4核cpu,就是有4个物理硬件内核，然而我们在生产环境的linux服务器上top的时候，出现的cpu个数实际上是逻辑cpu数，有可能linux服务器只有4核物理cpu,可是每个物理cpu分为两个逻辑cpu，这个时候我们在linux上top看的时候就是有8个cpu信息行数据。<br></code></pre></td></tr></table></figure><p>我们回顾一下Java，Java运行时我们一般管理的都是线程数，而所有的java线程均在JVM这个虚拟机进程中，于是在高并发情况下，当cpu资源充足时，我们需要根据cpu的逻辑核数来确定我们的线程池线程数(在高并发环境下一定要设置优化线程数啊！！！线程池就能设置线程数！！！)，比如我们是4个物理cpu,每个双核逻辑，一共逻辑八核cpu,此时，比如我们要做并发定时任务，这台服务器没有其它程序，8个cpu全都给我们自己用，那么我们的线程数最少也要设置成8，再细化，我们得根据程序执行的任务分别在cpu计算(正常处理程序业务逻辑)的耗时和cpuIO耗时（IO耗时比如查mysql数据库数据），假如我们定时跑批任务一个任务计算用时0.2秒，查数据库0.8秒(自己可以写程序监测)，那么可以参考如下公式：</p><p>总任务耗时/cpu耗时 = 多少个线程(每个逻辑cpu)</p><p>我们算出每个逻辑cpu要跑多少个线程后再乘以逻辑cpu的个数，就能算出来了</p><p>如下：</p><p>(0.2+0.8)/0.2=5个线程(每个逻辑cpu)</p><p>5*8 = 40</p><p>于是我们在线程池的时候应该这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(40);<br></code></pre></td></tr></table></figure><p>至于公式为什么要这么写，是因为IO操作的时候，cpu是空闲的，也就是说，0.8秒数据库操作的时候，cpu都是空闲的，那么我们就多开几个线程让cpu在这0.8秒的时候工作，开几个呢，要等0.8秒，一个任务cpu要计算0.2秒，0.8/0.2=4(个)，可是这个逻辑cpu还有一个主线程在那0.8秒上等着结果呢，所以是4+1=5（个）线程。 </p><p>上述我们回顾了Java中的线程数和CPU核数相关，接下来我们来看Go语言。</p><p>我们下面来仔细讲讲Go中的goroutine(实际是协程)，是如何天然的支持高并发的，它与Java中的线程Thread又有什么区别，为什么它比线程能更好的支持高并发。</p><h3 id="44-初始化结构体，匿名结构体，结构体指针-再讲"><a href="#44-初始化结构体，匿名结构体，结构体指针-再讲" class="headerlink" title="44.初始化结构体，匿名结构体，结构体指针(再讲)"></a>44.初始化结构体，匿名结构体，结构体指针(再讲)</h3><h3 id="45-方法中的值接收和指针接收的区别-方法进阶细节讲解"><a href="#45-方法中的值接收和指针接收的区别-方法进阶细节讲解" class="headerlink" title="45.方法中的值接收和指针接收的区别(方法进阶细节讲解)"></a>45.方法中的值接收和指针接收的区别(方法进阶细节讲解)</h3><p>我们之前讲了如果给一个类型绑定上一个接受者，就可以为这个类型添加一个这个类型独有的函数，只有这个类型对象自己能调用的函数，这个特殊的函数叫方法。</p><p>现在，我们讲一下方法关于传递接受者（自身引用）的进阶玩法。</p><p>Go语言中的参数传递</p><h3 id="46-基于包模块的Init函数"><a href="#46-基于包模块的Init函数" class="headerlink" title="46.基于包模块的Init函数"></a>46.基于包模块的Init函数</h3><h3 id="47-Go-语言中的初始化依赖项"><a href="#47-Go-语言中的初始化依赖项" class="headerlink" title="47.Go 语言中的初始化依赖项"></a>47.Go 语言中的初始化依赖项</h3><h3 id="48-slice相关知识点"><a href="#48-slice相关知识点" class="headerlink" title="48.slice相关知识点"></a>48.slice相关知识点</h3><p>slice的中文意思是切片。</p><p>要想理解切片，我们首先要理解数组。</p><p>数组是一个长度不能变化的容器，存储同一数据类型的数据。</p><p>比如：int数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">[1,2,3,4,5,6]<br></code></pre></td></tr></table></figure><p>切片是对数组中一截，一小段，一个子集的地址的截取，切片存储的是它指向的底层数组中的一小截数据的地址，切片中不存数据，创建切片也不会把数组中的数据copy一份，切片只是存储着数组中一部分连续的数据的地址，切片的每一个元素实际上都指向具体的数组的中一个元素。</p><p>切片内部包含三个元素：</p><p>1.底层数组（它指向的是哪一个数组）</p><p>​        我们要理解底层数组是什么，先举例：</p><p>​         [1,2,3]这是一个int数组，其中元素1 的地址是 0x0001,元素2的地址是0x0002，元素3的地址是0x0003。</p><p>​        那么如果我们创建一个通过数组[1,2,3]创建一个切片x。</p><p>​        这个x里面存储的并不是拷贝的另外一份新的[1,2,3]。</p><p>​        切片x实际上是这样子的：</p><p>​        [0x0001,0x0002,0x0003]</p><p>​        当我们取出x[0]的时候，它操作的实际上是0x0001这个地址的元素，而这个地址实际上就是数组[1,2,3]中的1的地址。</p><p>​        也就是说，当我们修改了数组[1,2,3]中的1后，比如 0x0001 = 5 ,切片x中的0元素的取值自动也不一样了，因为0x0001地址上存储的                 值已经被改成5了，而x[0]实际上还是0x0001,所以此时取出x[0],得到的就是5。</p><p>​        切片存储的每一个元素实际上是它指向的底层数组的每一个元素的地址。</p><p>​        也就是说切片是一个引用类型，它不存储元素，不拷贝元素，它存储数组元素的引用，通过修改切片会修改原来数组的值。</p><p>2.切片的长度</p><p>​        这个切片中有有几个元素，指向了数组中的几个连续的元素。</p><p>3.切片的容量</p><p>​        从切片在底层数组的起始下标(切片的首个元素)到底层数组的最后一个元素，一共有几个元素，切片的容量就是几。</p><p>​        例如：(下面先用伪代码示例，后面有具体可执行代码)</p><p>​        原数组：a  = [1,2,3,4,5,6,7,8]</p><p>​        切片:   b  = a[2:5] 从数组a的下标为2的开始，也就是具体数值是3开始，截取到下标为5，下标为5的是6，因为切片截取是左开右闭，所以切片中包括下标为2的数值3，不包含下标为5的数值6。</p><p>​        切片存储的地址指向的数据是：[3,4,5]</p><p>​        因为3，4，5有三个数，所以切片的长度是3。</p><p>​        因为从切片的起始元素3到底层数组的末尾元素8之间有6个元素，所以切片的容量是6。</p><p>​        修改切片实际上是修改切片指向的底层数组中的值。 </p><h3 id="49-Go中类似于函数指针的功能"><a href="#49-Go中类似于函数指针的功能" class="headerlink" title="49.Go中类似于函数指针的功能"></a>49.Go中类似于函数指针的功能</h3><p>Go中要实现函数指针非常简单。</p><p>因为Go中的函数也是一种类型。</p><p>所以我们只要声明一个变量，把某一个函数赋值给这个变量，就能实现函数指针的效果。</p><p>如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//加法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAddFun</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> x+y<br>&#125;<br><span class="hljs-comment">//减法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySubFun</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span> )</span> <span class="hljs-title">int</span></span>&#123;<br>   <span class="hljs-keyword">return</span> x-y;<br>&#125;<br><span class="hljs-comment">//函数变量(类似于函数指针)</span><br><span class="hljs-keyword">var</span> myPointFun <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//加法函数赋值给该函数变量，相当于函数指针指向加法函数</span><br>   myPointFun = myAddFun<br>   fmt.Printf(<span class="hljs-string">&quot;a+b = %d\n&quot;</span>,myPointFun(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>))<br>   <span class="hljs-comment">//减法函数赋值给该函数变量，相当于函数指针指向减法函数</span><br>   myPointFun = mySubFun<br>   fmt.Printf(<span class="hljs-string">&quot;a-b = %d\n&quot;</span>,myPointFun(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">a+b &#x3D; 30<br>a-b &#x3D; 50<br></code></pre></td></tr></table></figure><h3 id="50-Go有没有注解"><a href="#50-Go有没有注解" class="headerlink" title="50.Go有没有注解"></a>50.Go有没有注解</h3><p>原生的Go语言的SDK是不支持注解功能的，但是有一些其它的第三方机构为了实现自己的某些功能需求编写了一些自定义的注解。</p><h3 id="51-Go不能做大数据相关的开发"><a href="#51-Go不能做大数据相关的开发" class="headerlink" title="51.Go不能做大数据相关的开发"></a>51.Go不能做大数据相关的开发</h3><p>因为大数据的一些底层都是Java开发的，用Java实现接口开发功能非常方便快捷，对于Go语言的支持包比较少，另外就是一些算法库像numpy,pandas和一些机器学习，深度学习算法库Python支持的比较好，对于Go的支持很不好。</p><h3 id="52-Go没有泛型"><a href="#52-Go没有泛型" class="headerlink" title="52.Go没有泛型"></a>52.Go没有泛型</h3><p>Go中不支持泛型(明确)</p><h3 id="53-Go如何产生随机数-随机数和种子"><a href="#53-Go如何产生随机数-随机数和种子" class="headerlink" title="53.Go如何产生随机数(随机数和种子)"></a>53.Go如何产生随机数(随机数和种子)</h3><h3 id="54-Go如何打类似于-java-jar那种依赖包-a的工具依赖包-有了Module后不用这个了"><a href="#54-Go如何打类似于-java-jar那种依赖包-a的工具依赖包-有了Module后不用这个了" class="headerlink" title="54.Go如何打类似于(java jar那种依赖包).a的工具依赖包(有了Module后不用这个了)"></a>54.Go如何打类似于(java jar那种依赖包).a的工具依赖包(有了Module后不用这个了)</h3><p>Go中也有很多通过命令来完成辅助开发的工具，就像Java中jdk中的java javac javap等指令那种命令工具。</p><p>比如有go build xxx命令 , go  clean xxx命令， go run xxx命令……</p><p>Java中打jar包可以通过IDEA集成开发环境图形界面化直接打包，也可以使用jar命令在命令行操作中(使用不同的参数)进行打包。</p><p>与java jar命令打包对应的Go的命令是  go install,这个go install 也类似于 maven 中的install,它会把打成的.a后缀名结尾的工具包文件</p><p>放入${GOPATH} /pkg下。</p><p>具体使用如下示例：</p><p>注意：使用go install之前必须在操作系统的环境变量中定义${GOPATH}这个环境变量</p><p>1.查看我们当前的操作系统中环境变量有没有定义GOPATH。</p><p>2.查看${GOPATH}目录下是否有src,pkg,bin目录，并且保证我们的代码是在src下的。</p><p>3.打开一个命令行窗口，比如windows是cmd打开一个dos窗口。</p><p>4.我们在最开始之前已经把go的安装包下的包含Go操作指令的bin目录配置在了PATH环境变量中，所以此时我们可以不用管目录直接使用go  install 命令。</p><ol><li><p>例如目录结构如下：</p><p>com.mashibing.gotest</p><p>​            ————————-mygopackge</p><p>​                                                            MyUtil.go</p><p>  记住一点，此时MyUtil中不能是main包，也不能有main函数，否则打不出来.a结尾的依赖包。</p><p>此时编写执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go  install com&#x2F;mashibing&#x2F;gotest&#x2F;mygopackge<br></code></pre></td></tr></table></figure><p>此指令运行时，首先会去找${GOPATH}目录</p><p>然后把后面的com/mashibing/gotest/mygopackge拼接上去</p><p>也就是${GOPATH}/com/mashibing/gotest/mygopackge</p><p>然后会把${GOPATH}/com/mashibing/gotest/mygopackge下的所有.go文件，比如MyUtil.go全部打包压缩进mygopackge.a文件</p><p>最后会把mygopackage.a放入${GOPATH}/pkg/${标示操作系统的一个名字(这个不重要)}/com/mashibing/gotest/下。</p><p>最终.a文件存储的结构是这样的：</p><p>${GOPATH}/pkg/com/mashibing/gotest/mygopackge.a</p></li></ol><h3 id="55-Go中的依赖管理Module使用"><a href="#55-Go中的依赖管理Module使用" class="headerlink" title="55.Go中的依赖管理Module使用"></a>55.Go中的依赖管理Module使用</h3><h4 id="1-什么是GoModule-Go中Module和包的区别？"><a href="#1-什么是GoModule-Go中Module和包的区别？" class="headerlink" title="1.什么是GoModule?(Go中Module和包的区别？)"></a>1.什么是GoModule?(Go中Module和包的区别？)</h4><p>首先我们要理解一下Go的Module是一个什么概念？</p><p>我先简单的说一下，Go中的Module是GoSDK1.11后提出的一个新的类似于包的机制，叫做模块，在1.13版本后成熟使用，GoSDK中Module功能是和相当于一个包的增强版，一个模块类型的项目在根目录下必须有一个go.mod文件，这个模块项目内部可以有很多个不同的包，每个包下有不同的代码，我们下载依赖的时候是把这个模块下载下来(模块以压缩包(比如zip)的形式存储在${GOPATH}/pkg/mod/cache/下，源码文件也会在${GOPATH}/pkg/mod/下)。</p><p>我们导入模块的时候只需要引入一次，使用模块中不同的包的时候可以通过import模块下不同的包名，来引入不同包的功能。</p><p>比如下面的结构</p><p>​    ———–com.mashibing.module</p><p>​                        ———————–package1</p><p>​                                            ————–test1.go</p><p>​                        ————————package2</p><p>​                                             ————-test2.go</p><p>然后我们只需要在go.mod中引入这一个模块，就能在import的时候任意引入package1或package2。</p><h4 id="2-为什么要使用GoModule"><a href="#2-为什么要使用GoModule" class="headerlink" title="2.为什么要使用GoModule?"></a>2.为什么要使用GoModule?</h4><h5 id="1-团队协作开发中对于包的版本号的管理"><a href="#1-团队协作开发中对于包的版本号的管理" class="headerlink" title="1).团队协作开发中对于包的版本号的管理"></a>1).团队协作开发中对于包的版本号的管理</h5><p>在没有Module之前，我们都是把自己写的Go程序打成包，然后别的程序引用的话引入这个包。</p><p>可是在开发中这些包的版本有个明显的不能管理的问题。</p><p>比如我怎么知道这个包是今天开发的最新版还是明天开发的，我在团队协同开发中怎么把别人写的最新版本的包更新到我的项目中。</p><h5 id="2）便于开发中的依赖包管理"><a href="#2）便于开发中的依赖包管理" class="headerlink" title="2）便于开发中的依赖包管理"></a>2）便于开发中的依赖包管理</h5><p>其次，我们在开发中下载了别人的项目，怎么快速的观察有哪些依赖包，如何快速的把所有依赖包从仓库中下载下来，都是一个问题，</p><p>这两个问题就可以通过观察项目根目录下的go.mod文件的依赖模块列表和执行go mod download命令快速从第三方模块仓库中下载依赖包来完成。</p><h5 id="3-隔离管理不同类别的项目"><a href="#3-隔离管理不同类别的项目" class="headerlink" title="3).隔离管理不同类别的项目"></a>3).隔离管理不同类别的项目</h5><p>有了Module后，我们可以把我们自己的项目和系统的项目隔离管理，我们的项目不用必须放在${GOPATH}/src下了</p><h4 id="3-哪些项目能使用GoModule"><a href="#3-哪些项目能使用GoModule" class="headerlink" title="3.哪些项目能使用GoModule?"></a>3.哪些项目能使用GoModule?</h4><p>​    一个GoModule项目要想引入其它依赖模块，需要在根目录下的go.mod中添加对应的依赖模块地址。</p><p>   注意：！！！重点来了！！！</p><p>   GoModule只能引用同样是Module类型的项目，经常用于引用内部自己的项目。</p><p>   像maven仓库一样引用开源模块的依赖也是一个特别常用的场景。</p><p>   不过我们需要修改代理地址访问国内的第三方GoModule提供商。</p><p>   <a href="https://goproxy.cn/%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9B%BD%E5%86%85%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84GoModule%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8EJava%E4%B8%ADmaven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82">https://goproxy.cn/是一个国内的可访问的GoModule依赖仓库，类似于Java中maven中央仓库的概念。</a></p><h4 id="4-GoModule的版本问题？"><a href="#4-GoModule的版本问题？" class="headerlink" title="4.GoModule的版本问题？"></a>4.GoModule的版本问题？</h4><p>我们使用Go module之前，首先要保证我们的Go SDK是在1.13以及以上版本。(Go1.11以上就可以使用Module,但是需要设置一些开启等，1.13后默认开启)</p><p>因为在1.13版本上官方正式推荐使用，成为稳定版了。</p><p>Go也有代码仓库，比如可以使用github作为go项目的代码仓库，Go语言本身就提供了一个指令 go   get 来从指定的仓库中</p><p>拉取依赖包和代码，不过go get这个指令在开启模块功能和关闭模块功能下用法不一样，下面有开启模块下的用法。</p><h4 id="5-GoModule和Java中Maven的区别？"><a href="#5-GoModule和Java中Maven的区别？" class="headerlink" title="5.GoModule和Java中Maven的区别？"></a>5.GoModule和Java中Maven的区别？</h4><p>Go中的Module和Java中的Maven不同：</p><p>首先，Module是官方的SDK包自带的，它并非像maven一样还得安装maven插件之类的。</p><p>关于中央依赖仓库，Go和Java中的概念是类似的，都是国内的第三方提供的。</p><h4 id="6-如何开启GoModule-GO111MODULE"><a href="#6-如何开启GoModule-GO111MODULE" class="headerlink" title="6.如何开启GoModule?(GO111MODULE)"></a>6.如何开启GoModule?(GO111MODULE)</h4><p>具体我们如何使用Module呢？</p><p>我们首先要检查我们的GoSDK版本是1.11还是1.13之上。</p><p>如果是1.11的话我们需要设置一个操作系统的中的环境变量，用于开启Module功能，这个是否开启的环境变量名是GO111MODULE，</p><p>他有三种状态：</p><p>​    第一个是on 开启状态，在此状态开启下项目不会再去${GOPATH}下寻找依赖包。</p><p>​    第二个是off 不开启Module功能，在此状态下项目会去${GOPATH}下寻找依赖包。</p><p>​    第三个是auto自动检测状态，在此状态下会判断项目是否在${GOPATH}/src外，如果在外面，会判断项目根目录下是否有go.mod文件，如果均有则开启Module功能，如果缺任何一个则会从${GOPATH}下寻找依赖包。</p><p>GoSDK1.13版本后GO111MODULE的默认值是auto，所以1.13版本后不用修改该变量。</p><p>注意：在使用模块的时候，<code>GOPATH</code> 是无意义的，不过它还是会把下载的依赖储存在 <code>$&#123;GOPATH&#125;/src/mod</code> 中，也会把 <code>go install</code> 的结果放在 <code>$&#123;GOPATH&#125;/bin</code> 中。</p><p>​    windows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">set GO111MODULE&#x3D;on<br></code></pre></td></tr></table></figure><p>   linux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">export GO111MODULE&#x3D;on<br></code></pre></td></tr></table></figure><h4 id="7-GoModule的真实使用场景1："><a href="#7-GoModule的真实使用场景1：" class="headerlink" title="7.GoModule的真实使用场景1："></a>7.GoModule的真实使用场景1：</h4><p>接下来我们代入具体的使用场景：</p><p>今天，小明要接手一个新的Go项目，他通过GoLand中的git工具，从公司的git仓库中下载了一个Go的项目。(下载到他电脑的非${GOPATH}/src目录，比如下载到他电脑的任意一个自己的工作空间)</p><p>此时他要做的是：</p><p>​    1).先打开项目根目录下的go.mod文件看看里面依赖了什么工具包。(这个就是随便了解一下项目)</p><p>​    2).Go的中央模块仓库是Go的官网提供的，在国外是<a href="https://proxy.golang.org这个地址,可是在国内无法访问./">https://proxy.golang.org这个地址，可是在国内无法访问。</a></p><p>我们在国内需要使用如下的中央模块仓库地址：<a href="https://goproxy.cn/">https://goproxy.cn</a></p><p>我们Go中的SDK默认是去找国外的中央模块仓库的，如何修改成国内的呢？</p><p>我们知道，所有的下载拉取行为脚本实际上是从 go download 这个脚本代码中实现的，而在这个脚本中的源码实现里，肯定有一个代码是写的是取出操作系统中的一个环境变量，这个环境变量存储着一个地址，这个地址代表了去哪个中央模块仓库拉取。</p><p>在GoSDK中的默认实现里，这个操作系统的环境变量叫做GOPROXY，在脚本中为其赋予了一个默认值，就是国外的proxy.golang.org这个值。</p><p>我们要想修改，只需要在当前电脑修改该环境变量的值即可：</p><p>(注意，这个变量值不带https,这只是一个变量，程序会自动拼接https)</p><p>windows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">set GOPROXY&#x3D;goproxy.cn<br></code></pre></td></tr></table></figure><p>linux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">export GOPROXY&#x3D;goproxy.cn<br></code></pre></td></tr></table></figure><p> 3).切换到项目的根目录，也就是有go.mod的那层目录，打开命令行窗口。</p><p>​     执行 download指令(下载模块项目到${GOPATH}/pkg/mod下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go  mod  download<br></code></pre></td></tr></table></figure><p>4).如果不报错，代表已经下载好了，可以使用了，此时在项目根目录会生成一个go.sum文件。</p><p>   一会再讲解sum文件。</p><p>5).此时可以进行开发了。</p><h4 id="8-GoModule的真实使用场景2："><a href="#8-GoModule的真实使用场景2：" class="headerlink" title="8.GoModule的真实使用场景2："></a>8.GoModule的真实使用场景2：</h4><p>场景2：我们如何用命令创建一个Module的项目，(开发工具也能手动创建)。</p><p>​    切换到项目根目录，执行如下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go  mod init 模块名(模块名可不写)<br></code></pre></td></tr></table></figure><p>   然后会在根目录下生成一个go.mod文件</p><p>​    我们看看这个go.mod文件长啥样?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 刚才init指令后的模块名参数被写在module后了<br>module 模块名<br>&#x2F;&#x2F;表示使用GoSDK的哪个版本<br>go 1.14<br></code></pre></td></tr></table></figure><p> 修改go.mod文件中的依赖即可。</p><p>我们有两种方式下载和更新依赖：</p><p>1.修改go.mod文件，然后执行go mod down 把模块依赖下载到自己${GOPATH}/pkg/mod下，这里面装的是所有下载的module缓存依赖文件，其中有zip的包，也有源码，在一个项目文件夹下的不同文件夹下放着，还有版本号文件夹区分，每个版本都是一个文件夹。</p><p>2.直接在命令行使用go get package@version 更新或者下载依赖模块，升级或者降级模块的版本。(这里是开启模块后的go get指令用法)</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go get  github.com&#x2F;gin-contrib&#x2F;sessions@v0.0.1<br></code></pre></td></tr></table></figure><p>这个指令执行过后，会自动修改go.mod中的文件内容，不需要我们手动修改go.mod文件中的内容。</p><h4 id="9-go-mod文件详解"><a href="#9-go-mod文件详解" class="headerlink" title="9.go.mod文件详解"></a>9.go.mod文件详解</h4><p>接下来我们讲讲核心配置文件go.mod</p><p>go.mod内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;表示本项目的module模块名称是什么,别的模块依赖此模块的时候写这个名字<br>module test<br>&#x2F;&#x2F;表示使用GoSDK的哪个版本<br>go 1.14<br>&#x2F;&#x2F;require中声明的是需要依赖的包和包版本号<br>require (<br>    &#x2F;&#x2F;格式如下： 需要import导入的模块名  版本号<br>    &#x2F;&#x2F;         需要import导入的模块名2  版本号2    <br>    &#x2F;&#x2F;          ...                 ...<br>    github.com&#x2F;gin-contrib&#x2F;sessions v0.0.1<br>    github.com&#x2F;gin-contrib&#x2F;sse v0.1.0 &#x2F;&#x2F; indirect<br>    github.com&#x2F;gin-gonic&#x2F;gin v1.4.0<br>    github.com&#x2F;go-redis&#x2F;redis v6.15.6+incompatible<br>    github.com&#x2F;go-sql-driver&#x2F;mysql v1.4.1<br>    github.com&#x2F;golang&#x2F;protobuf v1.3.2 &#x2F;&#x2F; indirect<br>    github.com&#x2F;jinzhu&#x2F;gorm v1.9.11<br>    github.com&#x2F;json-iterator&#x2F;go v1.1.7 &#x2F;&#x2F; indirect<br>    github.com&#x2F;kr&#x2F;pretty v0.1.0 &#x2F;&#x2F; indirect<br>    github.com&#x2F;mattn&#x2F;go-isatty v0.0.10 &#x2F;&#x2F; indirect<br>    github.com&#x2F;sirupsen&#x2F;logrus v1.2.0<br>    github.com&#x2F;ugorji&#x2F;go v1.1.7 &#x2F;&#x2F; indirect<br>)<br>&#x2F;&#x2F;replace写法如下，表示如果项目中有引入前面的依赖模块，改为引用&#x3D;&gt;后面的依赖模块，<br>&#x2F;&#x2F;可以用于golang的国外地址访问改为指向国内的github地址,当然你在上面require直接写github就不用在这里repalce了<br>replace (<br>    golang.org&#x2F;x&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a &#x3D;&gt; github.com&#x2F;golang&#x2F;crypto v0.0.0-20190313024323-a1f597ede03a<br>)<br>&#x2F;&#x2F;忽略依赖模块，表示在该项目中无论如何都使用不了该依赖模块，可以用于限制使用某个有bug版本的模块<br>exclude(<br>    github.com&#x2F;ugorji&#x2F;go v1.1.7 <br>)<br></code></pre></td></tr></table></figure><p>注：go.mod 提供了module, require、replace和exclude四个命令</p><p>module语句指定包的名字（路径） require语句指定的依赖项模块 replace语句可以替换依赖项模块 exclude语句可以忽略依赖项模块</p><p>上面github.com/ugorji/go v1.1.7 //  indirect 有  indirect和非indirect</p><p>indirect代表此模块是间接引用的，中间隔了几个项目</p><p>这个不用特殊写，可以注释写便于识别和开发</p><h4 id="10-GoModule有哪些命令？如何使用？"><a href="#10-GoModule有哪些命令？如何使用？" class="headerlink" title="10.GoModule有哪些命令？如何使用？"></a>10.GoModule有哪些命令？如何使用？</h4><p>Go有如下关于Module的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;go mod   命令：<br>download  &#x2F;&#x2F;下载依赖模块到$&#123;GOPATH&#125;&#x2F;pkg&#x2F;mod<br>edit      &#x2F;&#x2F;一系列参数指令用于操作go.mod文件，参数太多，具体下面有例子<br>graph     &#x2F;&#x2F;输出显示每一个模块依赖了哪些模块<br>init      &#x2F;&#x2F;在一个非module项目的根目录下创建一个go.mod文件使其变为一个module管理的项目<br>tidy      &#x2F;&#x2F;根据项目实际使用的依赖包修改(删除和添加)go.mod中的文本内容<br>vendor    &#x2F;&#x2F;在项目根目录创建一个vender文件夹 然后把$&#123;GOPATH&#125;&#x2F;pkg&#x2F;mod下载的本项目需要的依赖模块拷贝到本项目的vender目录下<br>verify    &#x2F;&#x2F;校验$&#123;GOPATH&#125;&#x2F;pkg&#x2F;mod中的依赖模块下载到本地后是否被修改或者篡改过<br>why       &#x2F;&#x2F;一个说明文档的功能，用于说明一些包之间的为什么要这么依赖。(没啥用)<br></code></pre></td></tr></table></figure><h5 id="0-init和download"><a href="#0-init和download" class="headerlink" title="0). init和download"></a>0). init和download</h5><p>我们之前在案例中讲了init,download指令，这里不再赘述</p><h5 id="1-go-mod-edit"><a href="#1-go-mod-edit" class="headerlink" title="1).go mod edit"></a>1).go mod edit</h5><p> 是指在命令行用指令通过不同的参数修改go.mod文件，这个指令必须得写参数才能正确执行，不能空执行go mod edit  </p><p>参数1 ：-fmt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod edit -fmt<br></code></pre></td></tr></table></figure><p>格式化go.mod文件，只是格式规范一下，不做其它任何内容上的修改。</p><p>其它任何edit指令执行完毕后都会自动执行-fmt格式化操作。</p><p>这个使用场景就是我们如果不想做任何操作，就想试试edit指令，就只需要跟上-fmt就行，因为单独不加任何参数</p><p>只有go mod edit后面不跟参数是无法执行的。</p><p>我们如何升级降级依赖模块的版本，或者说添加新的依赖和移除旧的依赖呢</p><p>参数2： -require=path@version  /     -droprequire=path flags</p><p>添加一个依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod  edit -require&#x3D;github.com&#x2F;gin-contrib&#x2F;sessions@v0.0.1<br></code></pre></td></tr></table></figure><p>删除一个依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod edit -droprequire&#x3D;github.com&#x2F;gin-contrib&#x2F;sessions@v0.0.1<br></code></pre></td></tr></table></figure><p>这两个和go get package@version 功能差不多，但是官方文档更推荐使用go get来完成添加和修改依赖（go get 后的package和上面的path一个含义，都是模块全路径名）</p><p>参数3：-exclude=path@version and -dropexclude=path@version</p><p>排除某个版本某个模块的使用，必须有该模块才可以写这个进行排除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod edit -exclude&#x3D;github.com&#x2F;gin-contrib&#x2F;sessions@v0.0.1<br></code></pre></td></tr></table></figure><p>删除排除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod edit -dropexclude&#x3D;github.com&#x2F;gin-contrib&#x2F;sessions@v0.0.1<br></code></pre></td></tr></table></figure><p>简单来说，执行这两个是为了我们在开发中避免使用到不应该使用的包</p><p>…..还有好几个，基本很少用，省略了</p><h5 id="2-go-mod-graph"><a href="#2-go-mod-graph" class="headerlink" title="2).go mod graph"></a>2).go mod graph</h5><p>命令用法： 输出每一个模块依赖了哪些模块  无参数，直接使用 ，在项目根目录下命令行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod graph<br></code></pre></td></tr></table></figure><p>比如：</p><p>模块1    依赖了模块a</p><p>模块1    依赖了模块b</p><p>模块1    依赖了模块c</p><p>模块2    依赖了模块x</p><p>模块2    依赖了模块z</p><p>如下是具体例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:\$&#123;GOPAHT&#125;\file\project&gt;go mod graph<br>file\project github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;BurntSushi&#x2F;toml@v0.3.1<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;edgexfoundry&#x2F;go-mod-configuration@v0.0.3<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;edgexfoundry&#x2F;go-mod-core-contracts@v0.1.34<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;edgexfoundry&#x2F;go-mod-registry@v0.1.17<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;edgexfoundry&#x2F;go-mod-secrets@v0.0.17<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;gorilla&#x2F;mux@v1.7.1<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;pelletier&#x2F;go-toml@v1.2.0<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 github.com&#x2F;stretchr&#x2F;testify@v1.5.1<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap@v0.0.35 gopkg.in&#x2F;yaml.v2@v2.2.8<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-configuration@v0.0.3 github.com&#x2F;cenkalti&#x2F;backoff@v2.2.1+incompatible<br>github.com&#x2F;edgexfoundry&#x2F;go-mod-configuration@v0.0.3 github.com&#x2F;hashicorp&#x2F;consul&#x2F;api@v1.1.0<br></code></pre></td></tr></table></figure><h5 id="3-go-mod-tidy"><a href="#3-go-mod-tidy" class="headerlink" title="3).go mod  tidy"></a>3).go mod  tidy</h5><p>根据实际项目使用到的依赖模块，在go.mod中添加或者删除文本引用</p><p>   有一个参数可选项   -v 输出在go.mod文件中删除的引用模块信息</p><p>​    比如我们项目用到一个模块，go.mod中没写，执行后go.mod中就会添加上该模块的文本引用。</p><p>​    如果我们在go.mod中引用了一个模块，检测在真实项目中并没有使用，则会在go.mod中删除该文本引用。</p><p>使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go  mod  tidy -v<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">unused github.com&#x2F;edgexfoundry&#x2F;go-mod-bootstrap<br></code></pre></td></tr></table></figure><p>输出表示检测项目没有使用到该模块，然后从go.mod中把该包的引用文字给删除了。</p><h5 id="4-go-mod-vender"><a href="#4-go-mod-vender" class="headerlink" title="4).go mod vender"></a>4).go mod vender</h5><p>该指令会在项目中建立一个vender目录，然后把${GOPATG}/pkg/mod中下载的依赖拷贝到项目的vender目录中，方便管理和方便在idea中引用依赖。   -v参数可以在控制台输出相关的结果信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod vender -v <br></code></pre></td></tr></table></figure><h5 id="5-go-mod-verify"><a href="#5-go-mod-verify" class="headerlink" title="5).go mod verify"></a>5).go mod verify</h5><p> 验证下载到${GOPATH}/pkg/mod中的依赖模块有没有被修改或者篡改。</p><p>结果会输出是否被修改过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go mod verify<br></code></pre></td></tr></table></figure><p>比如输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">all modules verified<br></code></pre></td></tr></table></figure><p>这个是所有模块已经验证，代表没有被修改，如果被修改，会提示哪些被修改。</p><h5 id="6-go-mod-why"><a href="#6-go-mod-why" class="headerlink" title="6).go mod why"></a>6).go mod why</h5><p> 这个没啥用，说白了就是一个解释文档，输入参数和依赖他说明哪些包为啥要依赖这些包，不用看它，用处不大。</p><h4 id="11-go-sum详细讲解"><a href="#11-go-sum详细讲解" class="headerlink" title="11.go.sum详细讲解"></a>11.go.sum详细讲解</h4><h5 id="1-go-sum什么时候会更新或者新建生成？"><a href="#1-go-sum什么时候会更新或者新建生成？" class="headerlink" title="1).go.sum什么时候会更新或者新建生成？"></a>1).go.sum什么时候会更新或者新建生成？</h5><p>当我们通过go mod download 下载完依赖模块或者go get package@version更新了依赖包的时候</p><p>，会检查根目录下有没有一个叫go.sum的文件，没有的话则创建一个并写入内容，有的话会更新go.sum中的内容。</p><h5 id="2-go-sum是用来做什么的？"><a href="#2-go-sum是用来做什么的？" class="headerlink" title="2).go.sum是用来做什么的？"></a>2).go.sum是用来做什么的？</h5><p>go.sum的作用是用来校验你下载的依赖模块是否是官方仓库提供的，对应的正确的版本的，并且中途没有被黑客篡改的。</p><p>go.sum主要是起安全作用和保证依赖的版本肯定是官方的提供的那个版本，版本确认具体是确认你下载的那个模块版本里面的代码的和官方提供的模块的那个版本的代码完全相同，一字不差。</p><p>通过go.sum保证安全性是很有必要的，因为如果你的电脑被黑客攻击了，黑客可以截取你对外发送的文件，也可以修改发送给你的文件，那么就会产生一个问题：</p><p>本来的路径应该是这样的：      第三方模块依赖库————&gt;你的电脑</p><p>结果中间有黑客会变成这样:</p><p>第三方模块依赖库——–&gt;黑客修改了依赖库中的代码，植入病毒代码，并重新打成模块发送给你———&gt;你以为是官方的版本</p><p>结果黑客就把病毒代码植入到了你的项目中，你的项目就不安全了，面临着数据全部泄露的风险。</p><h5 id="3-go-sum是如何实现校验机制的-它包含什么内容？"><a href="#3-go-sum是如何实现校验机制的-它包含什么内容？" class="headerlink" title="3).go.sum是如何实现校验机制的?它包含什么内容？"></a>3).go.sum是如何实现校验机制的?它包含什么内容？</h5><p>说到校验安全机制，有一种常规的玩法就是使用不可逆加密算法，不可逆加密算法是指将a文本通过算法加密成b文本后，b文本永远也不能反着计算出a文本。</p><p>不可加密算法的具体是怎么应用的呢？它是如何起作用的？</p><p>我们在这里先讲一个不可逆的加密算法SHA-256算法。</p><p>SHA-256算法的功能就是将一个任意长度的字符串转换成一个固定长度为64的字符串，比如:</p><p>4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce</p><p>这里从4e07代表四个字符串，按此算，这个加密后的字符串为64个。</p><p>为什么是64个呢？</p><p>因为64个字符串每两个字符为一组，比如4e是一组，07是一组，也就是说有32组，每一组是一个十六进制的数值，一个十六进制的数值也就是两个字符用计算机中的8个字节内存空间存储，也就是一个十六进制的数字，有两个字符串，占8个字节，一个字节等同8位(bit)(位只能存储0和1两个值)，也就是说:</p><p>​            32（32个十六进制数，每个十六进制数用两个字符表示）*8字节=256位。</p><p>仔细看名字，SHA代表是算法的加密方式类型，256代表的是他这个是256位的版本。</p><p>具体原理实现是SHA内部定义了一系列固定数值的表，然后加密的时候无论是需要加密多少文字，它都按照一定的规则从需要加密的文字中按一定规则抽取其中的缩略一部分，然后拿缩略的一部分和SHA内部的固定数值表进行固定的hash映射和算术操作，这个hash映射和算术操作的顺序是固定写死的，公共数据表是写死的，这个写死的顺序和公共数据表就是这个算法的具体内容本质。</p><p>这样的话，因为抽取的是缩略的内容，所以我们可以把输出结果固定在64个字符，256位。</p><p>因为是缩略的内容， 所以我们不可能通过缩略的内容反推出完整的结果。</p><p>但是，相同的文本按照这个算法加密出来的64个字符肯定是相同的，同时，只要改变原需要加密文本的一个字符，也会造成加密出来的64个字符大不相同。</p><p>我们用SHA-256通常是这么用的：</p><p>​            A方   要   发送信息给     B方</p><p>​            B方   要确定信息是  A  方发送的，没有经过篡改</p><p>​            此时A和B同时约定一个密码字符串，比如abc。</p><p>​            这个abc只有A方和B方知道。</p><p>​            A 方把 需要传输的文本拼接上abc，然后通过SHA-256加密算出一个值，把原文本和算出的值全部发送给B。</p><p>​            B 方 拿出原文本，拼接上abc，进行SHA256计算，看看结果是否和传输过来的A传输的值一样，如果一样，代表中间没有被篡改。</p><p>​            为什么呢？</p><p>​            因为如果有一个黑客C想要篡改，他就得同时篡改原文本和算出的签名值。</p><p>​            可是C不知道密码是abc，它也就不能把abc拼接到原文后，所以它算出来的签名和B算出来的签名肯定不一致。</p><p>​            所以B如果自己算出的签名值与接收到的签名值不一致，B就知道不是A发过来的，就能校验发送端的源头是否是官方安全的了。</p><p>接下来我们讲一下go.sum的验证机制。</p><p>首先说下go.sum中存储的内容，这个文件存储的每一行都是如下格式</p><p>​                        模块名  版本号   hash签名值</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">github.com&#x2F;google&#x2F;uuid v1.1.1 h1:Gkbcsh&#x2F;GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF&#x2F;3gY&#x3D;   <br><br>github.com&#x2F;google&#x2F;uuid v1.1.1&#x2F;go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw&#x2F;LqOeaOT+nhxU+yHo&#x3D;<br></code></pre></td></tr></table></figure><p>这里的hash签名值是拿当前模块当前版本号内的所有代码字符串计算出来的一个值，就是通过上面讲解的SHA-256计算的。</p><p>所以哪怕是这个模块中的代码有一个字变了，计算出来的hash值也不相同。</p><p>第三方模块库在每发布一个新的模块版本后，会按照SHA-256计算出对应版本的hash值，然后提供给外部获取用于检验安全性。</p><p>当我们 go mod download 和 go  get package@version后 会更新go.mod中的模块路径和版本。</p><p>然后会更新或者创建根目录下go.sum文件中的模块名 版本号  和hash值。</p><p>在go.sum中的hash值是在下载和更新依赖包的时候，同时获取官方提供的版本号得来的。</p><p>也就是说，基本上go.sum中的文件都是从官网（外国）（中国是第三方模块仓库）上获得的正品版本号，这个版本号是仓库方自己算的，你只是获取到了存储到你自己的go.sum中。</p><p>具体如何获取版本号有个小知识点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">go module机制在下载和更新依赖的时候会取出操作系统中名为&#96;GOSUMDB&#96;的环境变量中的值，这个服务器地址值代表了从哪个第三方仓库获取对应的正品版本号。<br></code></pre></td></tr></table></figure><p>重点来了，当你在go build 打包创建go项目的时候，go build的内部指令会去拿你本地的模块文件进行SHA-256计算，然后拿到一个计算出来的结果值，之后它会拿此值和go.sum中的正确的从官网拉取的值进行对比，如果不一样，说明这个模块包不是官方发布的，也就是你本地的模块包和官方发布的模块包中的代码肯定有差异。</p><h2 id="四-专门详解Go并发编程相关知识"><a href="#四-专门详解Go并发编程相关知识" class="headerlink" title="四.专门详解Go并发编程相关知识"></a>四.专门详解Go并发编程相关知识</h2><h3 id="1-Go为什么天然支持高并发，纤程比线程的优势是什么？"><a href="#1-Go为什么天然支持高并发，纤程比线程的优势是什么？" class="headerlink" title="1.Go为什么天然支持高并发，纤程比线程的优势是什么？"></a>1.Go为什么天然支持高并发，纤程比线程的优势是什么？</h3><p>Go语言在设计的时候就考虑了充分利用计算机的多核处理器，具体表现为，Go中开启一个并发的任务以操作系统的线程资源调度为单位的，而是Go的创造者们自己写了一套管理多个任务的机制，在这个机制下，每一个并发的任务线程叫做纤程，这个纤程的作用等同一个线程，也是并发执行的，只不过纤程是在应用程序管理的，懂底层的可以讲是在用户态的一个线程，而Java中调度的线程是属于操作系统，也就是操作系统内核态的线程。</p><p>用户态的纤程归属于用户编写的软件管理和调度，优点是可以根据情况灵活实现堆栈的内存分配，最优化其中的运行资源配置。</p><p>内核态的线程归属于操作系统调度和管理，他底层是有windows或者linux操作系统底层的代码管理的，那么他就不灵活，每个线程分配的资源可能造成浪费，创建的线程数肯定也有一定的限制。</p><p>Go的创造可以为自己的语言和任务灵活配置资源，Linux和windows操作系统的代码是通用的，总不能为你这个语言修改源代码把。</p><p>在实际程序运行中，一个操作系统的内核态线程可能管理着好几个甚至数十个纤程(根据实际情况和设置不同而不同)，所以省去了线程时间片上下文切换的时间。</p><p>同时因为内部机制灵活，所以执行效率高，占用内存也少。</p><p>这就是Go语言的并发优势的核心所在。</p><h3 id="2-并发和并行的区别？"><a href="#2-并发和并行的区别？" class="headerlink" title="2.并发和并行的区别？"></a>2.并发和并行的区别？</h3><p>并发是指的一个角色在一段时间内通过来回切换处理了多个任务。</p><p>并行是指两个或者多个角色同时处理自己的任务。</p><p>举例：</p><p>并发：在一个小时内，你写了10分钟语文作业，又写了10分钟数学，之后又写了10分中英语作业，然后再从语文10分钟，数学10分钟，英文10分钟又来一次。</p><p>这个叫做你并发的写语文数学英语作业。</p><p>你一个一段时间（一个小时内）通过切换（一会写数学，一会写语文。。。），处理了多个任务（写了三门课的作业）</p><p>并行：你和小明同时写自己的作业。你们俩同时运行的状态叫做并行运作状态，强调的是你们两个人同时在处理任务(做作业)。</p><p>你和小明(两个以上的角色)同时写作业(处理自己的任务)。</p><p>在计算机中，比如有4个cpu，4个cpu同时工作，叫做这4个cpu并行执行任务，每个cpu通过时间片机制上下文切换处理100个小任务，叫做每个cpu并发的处理100个任务。</p><h3 id="3-Go是如何用Channel进行协程间数据通信数据同步的？"><a href="#3-Go是如何用Channel进行协程间数据通信数据同步的？" class="headerlink" title="3.Go是如何用Channel进行协程间数据通信数据同步的？"></a>3.Go是如何用Channel进行协程间数据通信数据同步的？</h3><p>go中的线程相关的概念是Goroutines(并发)，是使用go关键字开启。</p><p>Java中的线程是通过Thread类开启的。</p><p>在go语言中，一个线程就是一个Goroutines，主函数就是（主） main Goroutines。</p><p>使用go语句来开启一个新的Goroutines</p><p>比如：</p><p>普通方法执行</p><p>​    myFunction()</p><p>开启一个Goroutines来执行方法</p><p>​     go  myFunction()</p><p>java中是</p><p>​         new Thread(()-&gt;{ </p><p>​                //新线程逻辑代码</p><p>​         }).start();</p><p>参考下面的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">//并发开启新线程goroutine测试</span><br><br><span class="hljs-comment">//我的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello!!!&quot;</span>)<br>&#125;<br><span class="hljs-comment">//并发执行方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutineTestFunc</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello!!! Start Goroutine!!!&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   myFunction()</span><br><span class="hljs-comment">   //go goroutineTestFunc()</span><br><span class="hljs-comment">   //此时因为主线程有时候结束的快，goroutineTestFunc方法得不到输出，由此可以看出是开启了新的线程。</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-comment">//打开第二段执行</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   go goroutineTestFunc()</span><br><span class="hljs-comment">   time.Sleep(10*time.Second)//睡一段时间  10秒</span><br><span class="hljs-comment">   myFunction()</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>线程间的通信：</p><p>java线程间通信有很多种方式：</p><p>比如最原始的 wait/notify</p><p>到使用juc下高并发线程同步容器，同步队列</p><p>到CountDownLatch等一系列工具类</p><p>……</p><p>甚至是分布式系统不同机器之间的消息中间件，单机的disruptor等等。</p><p>Go语言不同，线程间主要的通信方式是Channel。</p><p>Channel是实现go语言多个线程（goroutines）之间通信的一个机制。</p><p>Channel是一个线程间传输数据的管道，创建Channel必须声明管道内的数据类型是什么</p><p>下面我们创建一个传输int类型数据的Channel</p><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>   fmt.Println(ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>channel是引用类型，函数传参数时是引用传递而不是值拷贝的传递。</p><p>channel的空值和别的应用类型一样是nil。</p><p>==可以比较两个Channel之间传输的数据类型是否相等。</p><p>channel是一个管道，他可以收数据和发数据。</p><p>具体参照下面代码示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><span class="hljs-comment">//channel发送数据和接受数据用 &lt;-表示,是发送还是接受取决于chan在  &lt;-左边还是右边</span><br><span class="hljs-comment">//创建一个传输字符串数据类型的管道</span><br><span class="hljs-keyword">var</span>  chanStr  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;main goroutine print Hello &quot;</span>)<br>   <span class="hljs-comment">//默认channel是没有缓存的，阻塞的，也就是说，发送端发送后直到接受端接受到才会施放阻塞往下面走。</span><br>   <span class="hljs-comment">//同样接收端如果先开启，直到接收到数据才会停止阻塞往下走</span><br>   <span class="hljs-comment">//开启新线程发送数据</span><br>   <span class="hljs-keyword">go</span> startNewGoroutineOne()<br>   <span class="hljs-comment">//从管道中接收读取数据</span><br>   <span class="hljs-keyword">go</span> startNewGoroutineTwo()<br>   <span class="hljs-comment">//主线程等待，要不直接结束了</span><br>   time.Sleep(<span class="hljs-number">100</span>*time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startNewGoroutineOne</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;send channel print Hello &quot;</span>)<br>   <span class="hljs-comment">//管道发送数据</span><br>   chanStr &lt;- <span class="hljs-string">&quot;Hello!!!&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startNewGoroutineTwo</span><span class="hljs-params">()</span></span>&#123;<br>   fmt.Println(<span class="hljs-string">&quot;receive channel print Hello &quot;</span>)<br>   strVar := &lt;-chanStr<br>   fmt.Println(strVar)<br>&#125;<br></code></pre></td></tr></table></figure><p>无缓存的channel可以起到一个多线程间线程数据同步锁安全的作用。</p><p>缓存的channel创建方式是</p><p>make(chan string,缓存个数)</p><p>缓存个数是指直到多个数据没有消费或者接受后才进行阻塞。</p><p>类似于java中的synchronized和lock</p><p>可以保证多线程并发下的数据一致性问题。</p><p>首先我们看一个线程不安全的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//多线程并发下的不安全问题</span><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA <span class="hljs-keyword">int</span> =<span class="hljs-number">1000</span><br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> moneyA;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>   &#125;()<br>   <span class="hljs-comment">//正常逻辑，只够扣款一单，可以多线程环境下结果钱扣多了</span><br>   time.Sleep(<span class="hljs-number">5</span>*time.Second)<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存为1的channel可以作为锁使用：</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//多线程并发下使用channel改造</span><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA  = <span class="hljs-number">1000</span><br><span class="hljs-comment">//减少金额管道</span><br><span class="hljs-keyword">var</span> synchLock = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-keyword">return</span> moneyA;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>      &lt;-synchLock<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<br>      synchLock&lt;<span class="hljs-number">-10</span><br>   &#125;()<br>   <span class="hljs-comment">//这样类似于java中的Lock锁，不会扣多</span><br>   time.Sleep(<span class="hljs-number">5</span>*time.Second)<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Go中的Goroutine使用和GMP模型？"><a href="#4-Go中的Goroutine使用和GMP模型？" class="headerlink" title="4.Go中的Goroutine使用和GMP模型？"></a>4.Go中的Goroutine使用和GMP模型？</h3><p>Go中的线程(实际是纤程)goroutine的底层管理和调度是在runtime包中自己实现的，其中遵循了GMP模型。</p><p>G就是一个goroutine，包括它自身的一些元信息。</p><p>M是指操作系统内核态的线程的一个虚拟表示，一个M就是操作系统内核态的一个线程。</p><p>P是一个组列表，P管理着多个goroutines,P还有一些用于组管理的元数据信息。</p><h3 id="5-Go的select怎么用？"><a href="#5-Go的select怎么用？" class="headerlink" title="5.Go的select怎么用？"></a>5.Go的select怎么用？</h3><p>Go中的select是专门用于支持更好的使用管道(channel)的。</p><p>我们之前虽然讲了能从管道中读取数据，但是这有一个缺陷，就是我们在一个Goroutine中不能同时处理读取多个channel，因为在一个Goroutine中，一个channel阻塞后就无法继续运行了，所以无法在一个Goroutine处理多个channel,而select很好的解决了这个问题。</p><p>select相当于Java中Netty框架的多路复用器的功能。</p><p>举例代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个缓存为1的chan</span><br>   myChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++&#123;<br>      <span class="hljs-comment">//select 的用法是，从上到下依次判断case 是否可执行，如果可执行，则执行完毕跳出select,如果不能执行，尝试下一个执行</span><br>      <span class="hljs-comment">//这里的可执行是指的不阻塞，也就是说，select从上到下开始挑选一个不阻塞的case执行，执行完毕后跳出，</span><br>      <span class="hljs-comment">//如果所有case都阻塞，则执行default</span><br>      <span class="hljs-comment">//如下输出结果，i=奇数的时候走case   myChan&lt;-i:，把奇数放入mychan</span><br>      <span class="hljs-comment">//走偶数的时候因为myChan中有数据了，则把上一个奇数打印出来。</span><br>      <span class="hljs-comment">//所以结果是 1  3  5  7  ...</span><br>      <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span>  data := &lt;-myChan:<br>               fmt.Println(data)<br>            <span class="hljs-keyword">case</span>   myChan&lt;-i:<br>            <span class="hljs-keyword">default</span>:<br>               fmt.Println(<span class="hljs-string">&quot;default !!!&quot;</span>)<br>      &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Go中的互斥锁-类似于Java中的ReentrantLock"><a href="#6-Go中的互斥锁-类似于Java中的ReentrantLock" class="headerlink" title="6.Go中的互斥锁(类似于Java中的ReentrantLock)"></a>6.Go中的互斥锁(类似于Java中的ReentrantLock)</h3><p>先按线程不安全的数据错误的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">var</span> wait sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    wait.Add(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">go</span> myAdd()<br>    <span class="hljs-keyword">go</span> myAdd()<br>    <span class="hljs-keyword">go</span> myAdd()<br>    <span class="hljs-keyword">go</span> myAdd()<br>    <span class="hljs-keyword">go</span> myAdd()<br>    wait.Wait()<br>    <span class="hljs-comment">//预期值等于5万，可是因为线程不安全错误，小于5万</span><br>    fmt.Printf(<span class="hljs-string">&quot;num = %d\n&quot;</span>,num)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">myAdd</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wait.Done()<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">10000</span>;i++ &#123;<br>        num+=<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打印输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">num &#x3D; 38626  <br></code></pre></td></tr></table></figure><p>互斥锁示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">var</span> wait sync.WaitGroup<br><br><span class="hljs-keyword">var</span> lock sync.Mutex<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   wait.Add(<span class="hljs-number">5</span>)<br>   <span class="hljs-keyword">go</span> myAdd()<br>   <span class="hljs-keyword">go</span> myAdd()<br>   <span class="hljs-keyword">go</span> myAdd()<br>   <span class="hljs-keyword">go</span> myAdd()<br>   <span class="hljs-keyword">go</span> myAdd()<br>   wait.Wait()<br>   <span class="hljs-comment">//预期值等于5万，可是因为线程不安全错误，小于5万</span><br>   fmt.Printf(<span class="hljs-string">&quot;num = %d\n&quot;</span>,num)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">myAdd</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">defer</span> wait.Done()<br>   <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">10000</span>;i++ &#123;<br>      lock.Lock()<br>      num+=<span class="hljs-number">1</span><br>      lock.Unlock()<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-Go中的读写锁-类似于Java中的ReentrantReadWriteLock"><a href="#7-Go中的读写锁-类似于Java中的ReentrantReadWriteLock" class="headerlink" title="7.Go中的读写锁(类似于Java中的ReentrantReadWriteLock)"></a>7.Go中的读写锁(类似于Java中的ReentrantReadWriteLock)</h3><p>读写锁用于读多写少的情况，多个线程并发读不上锁，写的时候才上锁互斥</p><p>读写锁示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><br><span class="hljs-comment">//金额</span><br><span class="hljs-keyword">var</span> moneyA  = <span class="hljs-number">1000</span><br><span class="hljs-comment">//读写锁</span><br><span class="hljs-keyword">var</span> rwLock sync.RWMutex;<br><span class="hljs-keyword">var</span> wait sync.WaitGroup<br><span class="hljs-comment">//添加金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtractMoney</span><span class="hljs-params">(subMoney <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   rwLock.Lock()<br>   time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>   moneyA-=subMoney<br>   rwLock.Unlock()<br>&#125;<br><br><span class="hljs-comment">//查询金额</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>   rwLock.RLock()<br>   result := moneyA<br>   rwLock.RUnlock()<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   wait.Add(<span class="hljs-number">2</span>)<br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">defer</span> wait.Done()<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">200</span>) &#123;<br>         subtractMoney(<span class="hljs-number">200</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;余额不足，无法扣款&quot;</span>)<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//添加查询金额</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">defer</span> wait.Done()<br>      <span class="hljs-keyword">if</span>(getMoney()&gt;<span class="hljs-number">900</span>) &#123;<br>         subtractMoney(<span class="hljs-number">900</span>)<br>         fmt.Printf(<span class="hljs-string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;余额不足，无法扣款&quot;</span>)<br>      &#125;<br>   &#125;()<br>   wait.Wait()<br>   fmt.Println(getMoney())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-Go中的并发安全Map-类似于CurrentHashMap"><a href="#8-Go中的并发安全Map-类似于CurrentHashMap" class="headerlink" title="8.Go中的并发安全Map(类似于CurrentHashMap)"></a>8.Go中的并发安全Map(类似于CurrentHashMap)</h3><p>Go中自己通过make创建的map不是线程安全的，具体体现在多线程添加值和修改值下会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">fatal error : concurrent map writes<br></code></pre></td></tr></table></figure><p>这个错类似于java中多线程读写线程不安全的容器时报的错。</p><p>Go为了解决这个问题，专门给我们提供了一个并发安全的map，这个并发安全的map不用通过make创建，拿来即可用，并且他提供了一些不同于普通map的操作方法。</p><p>参考如下代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-comment">//创建一个sync包下的线程安全map对象</span><br><span class="hljs-keyword">var</span> myConcurrentMap = sync.Map&#123;&#125;<br><span class="hljs-comment">//遍历数据用的</span><br><span class="hljs-keyword">var</span> myRangeMap = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//存储数据</span><br>   myConcurrentMap.Store(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;li_ming&quot;</span>)<br>   <span class="hljs-comment">//取出数据</span><br>   name,ok := myConcurrentMap.Load(<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">if</span>(!ok) &#123;<br>      fmt.Println(<span class="hljs-string">&quot;不存在&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">//打印值  li_ming</span><br>   fmt.Println(name)<br>   <span class="hljs-comment">//该key有值,则ok为true,返回它原来存在的值，不做任何操作；该key无值，则执行添加操作，ok为false,返回新添加的值</span><br>   name2, ok2 := myConcurrentMap.LoadOrStore(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiao_hong&quot;</span>)<br>   <span class="hljs-comment">//因为key=1存在，所以打印是   li_ming true</span><br>   fmt.Println(name2,ok2)<br>   name3, ok3 := myConcurrentMap.LoadOrStore(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xiao_hong&quot;</span>)<br>   <span class="hljs-comment">//因为key=2不存在，所以打印是   xiao_hong false</span><br>   fmt.Println(name3,ok3)<br>   <span class="hljs-comment">//标记删除值</span><br>   myConcurrentMap.Delete(<span class="hljs-number">1</span>)<br>   <span class="hljs-comment">//取出数据</span><br>   <span class="hljs-comment">//name4,ok4 := myConcurrentMap.Load(1)</span><br>   <span class="hljs-comment">//if(!ok4) &#123;</span><br>   <span class="hljs-comment">// fmt.Println(&quot;name4=不存在&quot;)</span><br>   <span class="hljs-comment">// return</span><br>   <span class="hljs-comment">//&#125;</span><br>   <span class="hljs-comment">//fmt.Println(name4)</span><br><br>   <span class="hljs-comment">//遍历数据</span><br>   rangeFunc()<br>&#125;<br><span class="hljs-comment">//遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rangeFunc</span><span class="hljs-params">()</span></span>&#123;<br>   myRangeMap.Store(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;xiao_ming&quot;</span>)<br>   myRangeMap.Store(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;xiao_li&quot;</span>)<br>   myRangeMap.Store(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;xiao_ke&quot;</span>)<br>   myRangeMap.Store(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;xiao_lei&quot;</span>)<br><br>   myRangeMap.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;data_key_value = :&quot;</span>,k,v)<br>      <span class="hljs-comment">//return true代表继续遍历下一个，return false代表结束遍历操作</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>   &#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-Go中的AtomicXXX原子操作类-类似于Java中的AtocmicInteger之类的"><a href="#9-Go中的AtomicXXX原子操作类-类似于Java中的AtocmicInteger之类的" class="headerlink" title="9.Go中的AtomicXXX原子操作类(类似于Java中的AtocmicInteger之类的)"></a>9.Go中的AtomicXXX原子操作类(类似于Java中的AtocmicInteger之类的)</h3><p>Go中的atomic包里面的功能和Java中的Atomic一样，原子操作类，原理也是cas,甚至提供了cas的api函数，这里不做过多讲解，</p><p>简单举一个代码示例，因为方法太多，详细的请参考api文档中的atomic包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync/atomic&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//简单举例</span><br>   <span class="hljs-keyword">var</span> num <span class="hljs-keyword">int64</span> = <span class="hljs-number">20</span><br>   atomic.AddInt64(&amp;num,<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-Go中的WaitGroup-类似于Java中的CountDownLatch"><a href="#10-Go中的WaitGroup-类似于Java中的CountDownLatch" class="headerlink" title="10.Go中的WaitGroup(类似于Java中的CountDownLatch)"></a>10.Go中的WaitGroup(类似于Java中的CountDownLatch)</h3><p>现在让我们看一个需求，比如我们开启三个并发任务，然后三个并发任务执行处理完毕后我们才让主线程继续往下面走。</p><p>这时候肯定不能用睡眠了，因为不知道睡眠多长时间。</p><p>这是Go中的sync包提供了一个WaitGroup的工具，他基本上和Java中的CountDownLatch的功能一致。</p><p>接下来让我们看代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//获取类似于CountDownLatch的对象</span><br><span class="hljs-keyword">var</span> wait sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//设置计数器任务为3，当3个任务全部done后，wait.Wait()才会松开阻塞</span><br>   wait.Add(<span class="hljs-number">3</span>)<br>   <span class="hljs-keyword">go</span> myFun1()<br>   <span class="hljs-keyword">go</span> myFun2()<br>   <span class="hljs-keyword">go</span> myFun3()<br>   <span class="hljs-comment">//阻塞</span><br>   wait.Wait()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">myFun1</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//计数器减1</span><br>   <span class="hljs-keyword">defer</span> wait.Done()<br>   <span class="hljs-comment">//睡眠五秒</span><br>   time.Sleep(time.Second*<span class="hljs-number">5</span>)<br>   fmt.Println(<span class="hljs-string">&quot;fun1执行完毕&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFun2</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//计数器减1</span><br>   <span class="hljs-keyword">defer</span> wait.Done()<br>   <span class="hljs-comment">//睡眠五秒</span><br>   time.Sleep(time.Second*<span class="hljs-number">5</span>)<br>   fmt.Println(<span class="hljs-string">&quot;fun2执行完毕&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFun3</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//计数器减1</span><br>   <span class="hljs-keyword">defer</span> wait.Done()<br>   <span class="hljs-comment">//睡眠五秒</span><br>   time.Sleep(time.Second*<span class="hljs-number">5</span>)<br>   fmt.Println(<span class="hljs-string">&quot;fun3执行完毕&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Go与Java&quot;&gt;&lt;a href=&quot;#Go与Java&quot; class=&quot;headerlink&quot; title=&quot;Go与Java&quot;&gt;&lt;/a&gt;Go与Java&lt;/h1&gt;&lt;h3 id=&quot;零-GoApi文档和中文社区网址&quot;&gt;&lt;a href=&quot;#零-GoApi文档和中文社区网址&quot; class=&quot;headerlink&quot; title=&quot;零.GoApi文档和中文社区网址&quot;&gt;&lt;/a&gt;零.GoApi文档和中文社区网址&lt;/h3&gt;&lt;p&gt;Go的中文api文档：&lt;a href=&quot;https://studygolang.com/pkgdoc&quot;&gt;https://studygolang.com/pkgdoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go中文社区网站：&lt;a href=&quot;https://studygolang.com/&quot;&gt;https://studygolang.com/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="go" scheme="https://qianmo.github.io/tags/go/"/>
    
  </entry>
  
</feed>
